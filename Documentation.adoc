= DustArch: DustVoice's Arch Linux from scratch
David Holland <info@dustvoice.de>
v4.2, 2019-12-28
:toc: left
:toc-title: Table Of Contents
:toclevels: 4
:doctype: book
:docinfo: shared
:source-highlighter: pygments
:icons: font
:last-update-label: Last modified:
:table-caption!:

== Inside the `archiso`

This section is aimed at providing help with the general installation of the customized Arch Linux from within official Arch Linux image.

=== ``Sy``nc up `pacman`

First of all we need to sync up `pacman` in order to be able to install packages

[source, console]
----
root@archiso ~ # pacman -Sy
----

=== Formatting the drive

First you have to list all the available drives by issuing

[source, console]
----
root@archiso ~ # fdisk -l
----

[NOTE]
====
The output of `fdisk -l` is dependent on your system configuration.
====

In my case, the partition I want to install the root file system on is `/dev/sdb2`.
`/dev/sdb3` will be my `swap` partition.

[NOTE]
====
A `swap` size *twice the size of your RAM* is recommended by a lot of people.
You should make the `swap` size *at least your RAM size* though.
====

[IMPORTANT]
====
If you haven't yet partitioned your disk, please refer to the link:https://wiki.archlinux.org/index.php/Partitioning[general partitioning tutorial] in the arch-wiki.
====

Now we need to format the partitions accordingly

[source, console]
----
root@archiso ~ # mkfs.ext4 /dev/sdb2
root@archiso ~ # mkswap /dev/sdb3
----

After doing that, we can turn on the `swap` and `mount` the root partition.

[source, console]
----
root@archiso ~ # swapon /dev/sdb3
root@archiso ~ # mount /dev/sdb2 /mnt
----

[NOTE]
====
If you have an additional `EFI system partition`, because of a _UEFI - GPT_ setup or e.g. an existing Windows installation, which we will assume to be located under `/dev/sda2` (`/dev/sda` is the disk of my Windows install), you'll have to `mount` this partition to the new systems `/boot` folder

[source, console]
----
root@archiso ~ # mkdir /mnt/boot
root@archiso ~ # mount /dev/sda2 /mnt/boot
----
====

=== Preparing the `chroot` environment

First it might make sense to edit `/etc/pacman.d/mirrorlist` to move the mirror(s) geographically closest to you to the top.

After that we can either install the *bare minimum packages* needed

[source, console]
----
root@archiso ~ # pacstrap /mnt base linux linux-firmware
----

or install *all packages present* on the archiso, which makes sense in our case

[source, console]
----
root@archiso ~ # pacstrap /mnt base base-devel linux linux-firmware $(pacman -Qq | tr '\n' ' ')
----

_This could take quite some time depending on your Internet connection speed._

After that generate a `fstab` using `genfstab`

[source, console]
----
root@archiso ~ # genfstab -U /mnt >> /mnt/etc/fstab
----

and you're ready to enter the `chroot` environment.

== Entering the `chroot`

[source, console]
----
root@archiso ~ # arch-chroot /mnt
----

Et Voila! You successfully ``chroot``ed inside your new system, greeted by a `bash` prompt.

=== Installing additional packages

First off you'll probably need an editor.
I'll use `neovim`

[source, console]
----
[root@archiso /]# pacman -S neovim
----

After that we'll make sure we get ourselves some basic utilities and enable the `NetworkManager.service` service, in order for the Internet connection to work upon booting into our fresh system later on.

[source, console]
----
[root@archiso /]# pacman -S sudo iputils dhcpcd dhclient grub dosfstools os-prober mtools networkmanager networkmanager-openvpn networkmanager-openconnect
[root@archiso /]# systemctl enable NetworkManager.service
----

Furthermore you'll also need to make sure `polkit` is installed

[source, console]
----
[root@archiso /]# pacman -S polkit
----

and then create a file `/etc/polkit-1/rules.de/50-org.freedesktop.NetworkManager.rules` to enable users of the `network` group to add new networks without `sudo`.

./etc/polkit-1/rules.de/50-org.freedesktop.NetworkManager.rules
[source, text]
----
polkit.addRule(function(action, subject) {
    if (action.id.indexOf("org.freedesktop.NetworkManager.") == 0 && subject.isInGroup("network")) {
        return polkit.Result.YES;
    }
});
----

If you use `UEFI`, you'll also need

[source, console]
----
[root@archiso /]# pacman -S efibootmgr
----

=== Master of time

After that you have to set your timezone and update the system clock.

Generally speaking, you can find all the different timezones under `/usr/share/zoneinfo`.
For me it is `/usr/share/zoneinfo/Europe/Berlin`.
Now I would have to issue

[source, console]
----
[root@archiso /]# ln -s /usr/share/zoneinfo/Europe/Berlin /etc/localtime
[root@archiso /]# hwclock --systohc --utc
----

Now you can also enable time synchronization over network and check that everything is alright

[source, console]
----
[root@archiso /]# timedatectl set-timezone Europe/Berlin
[root@archiso /]# timedatectl set-ntp true
[root@archiso /]# timedatectl status
----

=== Master of locales

Now you have to generate your locale information.

For that you have to edit `/etc/locale.gen` and uncomment the `locale` lines you want to enable.

[NOTE]
====
I recommend to always uncomment `en_US.UTF-8 UTF8` for development purposes, even if you want to use another language primarily.
====

In my case I only uncommented the `en_US.UTF-8 UTF8` line

./etc/locale.gen
[source, text]
----
en_US.UTF-8 UTF8
----

After that you still have to actually generate the locales by issuing

[source, console]
----
[root@archiso /]# locale-gen
----

and set the locale

[source, console]
----
[root@archiso /]# localectl set-locale LANG="en_US.UTF-8"
----

and we're done with this part.

=== Naming your machine

Now we can set the `hostname` and add `hosts` entries.

==== `hostname`

To change the `hostname`, simply edit `/etc/hostname`, enter the desired name, then save and quit.

./etc/hostname
[source, text]
----
DustArch
----

==== `hosts`

Now we need to specify some `hosts` entries by editing `/etc/hosts`

./etc/hosts
[source, text]
----
# Static table lookup for hostnames.
# See hosts(5) for details.

127.0.0.1   localhost           .
::1         localhost           .
127.0.1.1   DustArch.localhost  DustArch
----

[source, console]
----
[root@archiso /]# exit
root@archiso ~ # arch-chroot /mnt
----

=== User setup

Now you should probably change the default `root` password and create a new non-``root`` user for yourself, as using your new system purely through the native `root` user is not recommended from a security standpoint.

==== Give `root` a password

To change the password for the current user (the `root` user) do

[source, console]
----
[root@DustArch /]# passwd
----

and choose a new password.

[#create-a-personal-user]
==== Create a personal user

We are going to make sure the `fish` shell is installed, create a new user, set the password for this user, make sure the `sudo` package is installed and allow the `wheel` group `sudo` access.

[source, console]
----
[root@DustArch /]# pacman -S fish
[root@DustArch /]# useradd -m -p "" -G "adm,audio,floppy,kvm,log,lp,network,rfkill,scanner,storage,users,optical,power,wheel" -s /usr/bin/fish dustvoice
[root@DustArch /]# passwd dustvoice
[root@DustArch /]# pacman -S sudo
----

We now have to allow the `wheel` group `sudo` access.

For that we edit `/etc/sudoers` and uncomment the `%wheel` line

./etc/sudoers
[source, text]
----
%wheel ALL=(ALL) ALL
----

You could also add a new line below the `root` line

./etc/sudoers
[source, text]
----
root ALL=(ALL) ALL
----

with your new username

./etc/sudoers
[source, text]
----
dustvoice ALL=(ALL) ALL
----

to solely grant yourself `sudo` privileges.

=== Preparing to boot

Now onto installing the boot manager.
We will use `grub` in this guide.

First make sure, all the required packages are installed

[source, console]
----
[root@DustArch /]# pacman -S grub dosfstools os-prober mtools
----

and if you want to use `UEFI`, also

[source, console]
----
[root@DustArch /]# pacman -S efibootmgr
----

==== `BIOS`

If you chose the `BIOS - MBR` variation, you'll have to *do nothing special*

If you chose the `BIOS - GPT` variation, you'll have to *have a `+1M` boot partition* created with the partition type set to `BIOS boot`.

In both cases you'll have to *run the following comman* now

[source, console]
----
[root@DustArch /]# grub-install --target=i386-pc /dev/sdb
----

[NOTE]
====
It should obvious that you would need to replace `/dev/sdb` with the disk you actually want to use.
Note however that you have to specify a *disk* and *not a partition*, so *no number*.
====

==== `UEFI`

If you chose the `UEFI - GPT` variation, you'll have to *have the `EFI System Partition` mounted* at `/boot` (where `/dev/sda2` is the partition holding said `EFI System Partition` in my particular setup)

Now *install `grub` to the `EFI System Partition`*

[source, console]
----
[root@DustArch /]# grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub --recheck
----

[IMPORTANT]
====
If you've planned on dual booting arch with Windows and therefore reused the `EFI System Partition` created by Windows, you might not be able to boot to grub just yet.

In this case, boot into Windows, open a `cmd` window as Administrator and type in

[source, console]
----
bcdedit /set {bootmgr} path \EFI\grub\grubx64.efi
----

To make sure that the path is correct, you can just

[source, console]
----
[root@DustArch /]# ls /boot/EFI/grub
----

to make sure, that the `grubx64.efi` file is really there.
====

==== `grub` config

In all cases, you now have to create the main configuration file.

But before we actually generate it, we'll make some changes to the default `grub` settings.

===== Adjust the timeout

First of all, I want my `grub` menu to wait indefinitely for my command to boot a OS.

./etc/default/grub
[source, text]
----
GRUB_TIMEOUT=-1
----

[NOTE]
====
I decided on this, because I'm dual booting with Windows and after Windows updates itself, I don't want to accidentally boot into my Arch Linux, just because I wasn't quick enough to select it from the `grub` menu.

Of course you can set this parameter to whatever you want.
====

Another way of achieving what I described previously, would be to make `grub` remember the last selection.
For that we would have to adjust the file accordingly

./etc/default/grub
[source, text]
----
GRUB_DEFAULT=saved
GRUB_SAVEDEFAULT="true"
----

===== Enable the recovery

After that I also want the recovery option showing up, which means that besides the standard and fallback images, also the recovery one would show up.

./etc/default/grub
[source, text]
----
GRUB_DISABLE_RECOVERY=false
----

===== NVIDIA fix

Now, as I'm using the binary nvidia driver for my graphics card, I also want to make sure, to revert `grub` back to text mode, after I selected a boot entry.

./etc/default/grub
[source, text]
----
GRUB_GFXPAYLOAD_LINUX=text
----

===== Add power options

I also want to add 2 new menu entries, to enable me to shut down the PC, or reboot it, right from the `grub` menu.

./etc/grub.d/40-custom
[source, text]
----
menuentry '=> Shutdown' {
    halt
}

menuentry '=> Reboot' {
    reboot
}
----

===== Installing `memtest`

As I want all possible options to possibly troubleshoot my PC, without booting into a live image, right there in my `grub` menu, I also want to have a memory tester there.

====== `BIOS`

For a `BIOS` setup, you'll need `memtest86+`

[source, console]
----
[root@DustArch /]# pacman -S memtest86+
----

====== `UEFI`

For a `UEFI` setup, you'll need `memtest86-efi`.

[WARNING]
====
In order to install that `AUR` package, you'll need to switch to your normal user, because `makepkg` doesn't run as root.
====

[source, console]
----
[root@DustArch /]# pacman -S base-devel
[root@DustArch /]# sudo -iu dustvoice
[dustvoice@DustArch ~]$ git clone https://aur.archlinux.org/memtest86-efi
[dustvoice@DustArch ~]$ cd memtest86-efi
[dustvoice@DustArch ~/memtest86-efi]$ makepkg -si
[dustvoice@DustArch ~/memtest86-efi]$ cd ..
[dustvoice@DustArch ~]$ rm -rf memtest86-efi
[dustvoice@DustArch ~]$ exit
----

Now we still need to tell `memtest86-efi` how to install itself.

[source, console]
----
[root@DustArch /]# memtest86-efi -i
----

Now select option 3, to install it as a `grub2` menu item.

===== Generating the config

Now we can finally generate our `grub.cfg`

[source, console]
----
[root@DustArch /]# grub-mkconfig -o /boot/grub/grub.cfg
----

Now you're good to boot into your new system

== Inside the `DustArch`

=== Someone there?

First we have to check if the network interfaces are set up properly

[source, console]
----
dustvoice@DustArch ~> ip link
----

This outputs the interface status report.

To make sure that you really have a working _Internet_ connection, issue

[source, console]
----
dustvoice@DustArch ~> ping archlinux.org
----

Everything should run smoothly if you have a wired connection.
If there is still no connection try restarting the `NetworkManager.service` service

[source, console]
----
dustvoice@DustArch ~> sudo systemctl restart NetworkManager.service
----

and then try `ping` again.

If you're indeed trying to utilize a Wi-Fi connection, use `nmcli`, the `NetworkManager` command line tool, or `nmtui`, the `NetworkManager` terminal user interface, to connect to a Wi-Fi network.

[NOTE]
====
I never got `nmtui` to behave like I wanted it to, in my particular case at least, which is the reason why I use `nmcli` or the GUI tools.
====

First make sure, the scanning of nearby Wi-Fi networks is enabled for your Wi-Fi device

[source, console]
----
dustvoice@DustArch ~> nmcli r
----

and if not, enable it

[source, console]
----
dustvoice@DustArch ~> nmcli r wifi on
----

Now make sure your Wi-Fi interface appears under

[source, console]
----
dustvoice@DustArch ~> nmcli d
----

Rescan for available networks

[source, console]
----
dustvoice@DustArch ~> nmcli d wifi rescan
----

and list all found networks

[source, console]
----
dustvoice@DustArch ~> nmcli d wifi list
----

After that connect to the network

[source, console]
----
dustvoice@DustArch ~> nmcli d wifi connect --ask
----

Now try ``ping``ing again.

=== Update and upgrade

After making sure that you have established an Internet connection, you can then proceed to update and upgrade all installed packages by issuing

[source, console]
----
dustvoice@DustArch ~> sudo pacman -Syu
----

=== Enabling the `multilib` repository

In order to make 32-bit packages available to `pacman`, we'll need to enable the `multilib` entry in `/etc/pacman.conf` first. Simply uncomment

./etc/pacman.conf
[source, text]
----
[multilib]
Include = /etc/pacman.d/mirrorlist
----

=== Setting the correct shell

I'll be using the `fish` shell.

We already set the correct shell for the `dustvoice` user in the <<create-a-personal-user>> step, but I want to use `fish` for the `root` user too, so I'll have to change ``root``'s default shell to it.

[source, console]
----
dustvoice@DustArch ~> chsh -s /usr/bin/fish root
----

Don't worry about the looks by the way, we're gonna change all that in just a second.

=== Version control

Next you'll probably want to install `git`.
Just do

[source, console]
----
dustvoice@DustArch ~> sudo pacman -S git
----

and you're good to go.
We'll care about the `.gitconfig` in just a second.

=== Security is important

If you've followed the tutorial using a recent version of Arch Linux, you'll probably already have the most recent version of `gnupg` installed by default.
Just to make sure, issue

[source, console]
----
dustvoice@DustArch ~> sudo pacman -S gnupg
----

==== Smartcard shenanigans

After that you'll still have to setup `gnupg` correctly.
In my case I have my private keys stored on a smartcard.
To use it, I'll have to install some packages first

[source, console]
----
dustvoice@DustArch ~> sudo pacman -S pcsclite libusb-compat ccid opensc
----

and then enable and start the `pcscd` service

[source, console]
----
dustvoice@DustArch ~> sudo systemctl enable pcscd.service
dustvoice@DustArch ~> sudo systemctl start pcscd.service
----

[#additional-tools-setup-home]
=== Additional required tools

To minimize the effort required in the following steps, we'll install most of the required tools now

[source, console]
----
dustvoice@DustArch ~> pacman -S make cmake clang jdk-openjdk pyhton pyhton-pip pass openssh
----

[#setup-home]
=== Setting up a `home` environment

In this step we're going to setup a home environment for both the `root` and my personal `dustvoice` user.

[NOTE]
====
In my case these 2 home environments are mostly equivalent, which is why I'll execute the following commands as the `dustvoice` user first and then switch to the `root` user and repeat the same commands.
====

[NOTE]
====
In my case, I want to access all my `git` repositories with my `gpg` key on my smartcard.
For that I have to configure the `gpg-agent` though.
So I will have to reside to first use the `https` url and later change the url in the corresponding `.git/config` file.
====

==== Use `dotfiles` for a base config

[source, console]
----
dustvoice@DustArch ~> git init
dustvoice@DustArch ~> git remote add origin https://github.com/DustVoice/dotfiles.git
dustvoice@DustArch ~> git fetch
dustvoice@DustArch ~> git reset origin/master --hard
dustvoice@DustArch ~> git branch --set-upstream-to=origin/master master
----

==== Set up `gpg`

Before we'll be able to update the ``submodule``s (`nvim` config files and ``pass``word-store), we will have to setup our `gpg` key as a `ssh` key

[source, console]
----
[I] dustvoice@DustArch ~>
$ chmod 700 .gnupg
[I] dustvoice@DustArch ~>
$ gpg --card-status
[I] dustvoice@DustArch ~>
$ gpg --card-edit
(insert) gpg/card> fetch
(insert) gpg/card> q
[I] dustvoice@DustArch ~>
$ gpg-connect-agent updatestartuptty /bye
[I] dustvoice@DustArch ~>
$ git remote set-url origin git@github.com:DustVoice/dotfiles.git
[I] dustvoice@DustArch ~>
$ exit
----

[NOTE]
====
You would have to adapt the `keygrip` present in the `~/.gnupg/sshcontrol` file to your specific `keygrip`, retrieved with `gpg -K --with-keygrip`.
====

==== Finalize the `dotfiles`

Now log back in and continue

[source, console]
----
[I] dustvoice@DustArch ~
$ git submodule update --init --recursive
[I] dustvoice@DustArch ~
$ cd .config/nvim
[I] dustvoice@DustArch ~/.config/nvim
$ echo 'let g:platform = "linux"' >> platform.vim
[I] dustvoice@DustArch ~/.config/nvim
$ echo 'let g:use_autocomplete = 3' >> custom.vim
[I] dustvoice@DustArch ~/.config/nvim
$ echo 'let g:use_clang_format = 1' >> custom.vim
[I] dustvoice@DustArch ~/.config/nvim
$ echo 'let g:use_font = 0' >> custom.vim
[I] dustvoice@DustArch ~/.config/nvim
$ pip3 install neovim
[I] dustvoice@DustArch ~/.config/nvim
$ nvim --headless +PlugInstall +qa
[I] dustvoice@DustArch ~/.config/nvim
$ cd plugged/YouCompleteMe
[I] dustvoice@DustArch ~/.config/nvim/plugged/YouCompleteMe
$ python3 install.py --clang-completer --java-completer
[I] dustvoice@DustArch ~/.config/nvim/plugged/YouCompleteMe
$ cd ~
----

==== `gpg-agent` forwarding

Now there is only one thing left to do, in order to make the `gpg` setup complete: `gpg-agent` forwarding over ssh.
This is very important for me, as I want to use my smartcard on my development server too, which requires me, to forward/tunnel my `gpg-agent` to my remote machine.

First of all, I want to setup a config file for `ssh`, as I don't want to pass all parameters manually to ssh every time.

.~/.ssh/config
[source, text]
----
Host <connection name>
    HostName <remote address>
    ForwardAgent yes
    ForwardX11 yes
    RemoteForward <remote agent-socket> <local agent-extra-socket>
    RemoteForward <remote agent-ssh-socket> <local agent-ssh-socket>
----

[NOTE]
====
You would of course, need to adapt the content in between the `<` and `>` brackets.

To get the paths needed as parameters for `RemoteForward`, issue

[source, console]
----
[I] dustvoice@DustArch ~
$ !gpgconf --list-dirs
----
====

Now you'll still need to enable some settings on the remote machine.

./etc/ssh/sshd_config
[source, text]
----
StreamLocalBindUnlink yes
AllowAgentForwarding yes
X11Forwarding yes
----

Now just restart your remote machine and you're ready to go.

==== `JUCE` and `FRUT`

Your personal environment will be complete, after getting `JUCE` and `FRUT`

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://github.com/WeAreROLI/JUCE.git
[I] dustvoice@DustArch ~
$ cd JUCE
[I] dustvoice@DustArch ~/JUCE
$ git checkout develop
[I] dustvoice@DustArch ~/JUCE
$ cd ..
[I] dustvoice@DustArch ~
$ git clone https://github.com/McMartin/FRUT.git
----

==== Back to your ``root``s

As mentioned before, you would now switch to the `root` user, either by logging in as `root`, or by using

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo -iu root
----

Now go back to <<setup-home>> to repeat all commands for the `root` user.

[WARNING]
====
A native login would be better compared to `sudo -iu root`, as there could be some complications, like already running `gpg-agent` instances, etc., which you would need to manually resolve, when using `sudo -iu root`.
====

=== Password management

I'm using `pass` as my password manager.
As we already installed it in the <<additional-tools-setup-home>> step and updated the `submodule` that holds our `.password-store`, there is nothing left to do in this step

=== `python`

Python has become really important for a magnitude of use cases.
We need `python3` in particular as well as `pip` for it.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S python python-pip
----

[NOTE]
====
For `asciidoctor`, which will be installed in just a second, we also need to install the `pygments` module

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pip3 install pygments
----
====

=== `ruby` & `asciidoctor`

In order to use `asciidoctor`, we have to install `ruby` and `rubygems`.
After that we can install `asciidoctor` and all its required gems.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S ruby rubygems
[I] dustvoice@DustArch ~
$ gem install asciidoctor --pre
[I] dustvoice@DustArch ~
$ gem install asciidoctor-pdf --pre
[I] dustvoice@DustArch ~
$ gem install asciidoctor-epub3 --pre
[I] dustvoice@DustArch ~
$ gem install pygments.rb --pre
----

Now the only thing left, in my case at least, is adding `~/.gem/ruby/2.6.0/bin` to your path.

[NOTE]
====
Please note that if you run a ruby version different from `2.6.0`, you have to use the `bin` path for that version.
====

For `fish` you'll want to run the following command

[source, console]
----
[I] dustvoice@DustArch ~
$ set -U fish_user_paths $fish_user_paths ~/.gem/ruby/2.6.0/bin
----

[NOTE]
====
If you use another shell than `fish`, you might have to do something different to add a directory to your `PATH`.
====

=== Using `JUCE`

In order to use `JUCE`, you'll need to have some dependency packages installed

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S clang gcc freeglut alsa-lib gnutls libcurl-gnutls freetype2 jack2 libx11 libxcomposite libxinerama libxrandr mesa webkit2gtk
----

If you want to use every feature of `JUCE` you'll need to install 2 more packages

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S ladspa lib32-freeglut
----

=== Additional development tools

Here are just some examples of development tools one could install in addition to what we already have.

==== Code formatting

We already have `clang-format` as a code formatter, but this only works for ``C``-family languages.
For `java` stuff, we can use `astyle`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S astyle
----

==== Documentation

To generate a documentation from source code, I mostly use `doxygen`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S doxygen
----

==== Build tools

In addition to `make`, I'll often times use `ninja` for my builds

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S ninja
----

[#setting-up-fstab]
=== `fstab`

In my case, I'm sharing an `exFat` partition between my `DustArch` and my Windows.
This was a result of some major inconvenience because of some weird `NTFS` permission stuff, which apparently Windows didn't like.
Since I've avoided directly writing to Windows partitions since then, I'll quickly demonstrate what `fstab` entries I have and why

./etc/fstab
[source, text, linenums]
----
UUID=e26de048-6147-42e5-a34b-59f1a50621bb       /               ext4            rw,relatime             0 1

UUID="C8E3-A0FD"                                /boot           vfat            defaults                0 1

UUID="DC88-5A4E"                                /mnt/projects   exfat           rw,relatime             0 0

UUID=7A16569B51903310                           /mnt/data       ntfs            ro,nosuid,nodev,noauto  0 0
----

The

. entry should be pretty straight forward.
It's my root partition of my `DustArch` install.

. entry is quite important too.
It's my `EFI System Partition`, which gets mounted at boot time, in order to prevent kernel orphaning, which means, that the kernel version installed on the system doesn't match the one on the `boot` partition.

. entry is my shared `exFat` partition, which we are allowed to write to.

. entry is important, because of the options.
These options prevent me from modifying files on that `NTFS` partition.

=== Audio

Well, why wouldn't you want audio...

==== `alsa`

[NOTE]
====
You're probably better off using `pulseaudio` and/or `jack`.
====

To quickly setup audio this way, install `alsa` and `alsa-utils`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S alsa alsa-utils
----

Now choose the sound card you want to use

[source, console]
----
[I] dustvoice@DustArch ~
$ cat /proc/asound/cards
----

and then create `/etc/asound.conf`

./etc/asound.conf
[source, text]
----
defaults.pcm.card 2
defaults.ctl.card 2
----

[NOTE]
====
It should be apparent, that you would have to switch out `2` with the number corresponding to the sound card you want to use.
====

==== `pulseaudio`

Some applications require `pulseaudio`, or work better with it, for example `discord`, so it might make sense to use `pulseaudio`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S pulseaudio pulsemixer pavucontrol
----

For enabling real-time priority for `pulseaudio` on Arch Linux, please make sure your user is part of the `audio` group and edit the file `/etc/pulse/daemon.conf`, so that you uncomment the lines

./etc/pulse/daemon.conf
[source, text]
----
high-priority = yes
nice-level = -11

realtime-scheduling = yes
realtime-priority = 5
----

If your system can handle the load, you can also increase the remixing quality, by changing the `resample-method`

./etc/pulse/daemon.conf
[source, text]
----
resample-method = speex-float-10
----

Of course a restart of the `pulseaudio` daemon is necessary to reflect the changes you just made

[source, console]
----
[I] dustvoice@DustArch ~
$ pulseaudio --kill
[I] dustvoice@DustArch ~
$ pulseaudio --start
----

==== `jack`

If you either want to manually control audio routing, or if you use some kind of audio application like `ardour`, you'll probably want to use `jack`.

To install `jack` and a GUI to configure it, just do

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S jack2 cadence
----

If you also want to use `pulseaudio` applications, that don't have native support for `jack`, you'll need to install `pulseaudio-jack`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S pulseaudio-jack
----

==== Audio handling

To also play audio, we need to install some other packages too

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S soc libao libmad libid3tag wavpack libpulse opus file twolame
----

Now you can simply do

[source, console]
----
[I] dustvoice@DustArch ~
$ play audio.wav
[I] dustvoice@DustArch ~
$ play audio.mp3
----

etc. to play audio.

=== Bluetooth

To set up Bluetooth, we need to install the `bluez` and `bluez-util` packages in order to have at least a command line utility `bluetoothctl` to configure connections

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S bluez bluez-utils
----

Now we need to check if the `btusb` kernel module was already loaded

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo lsmod | grep btusb
----

After that we'll enable and start the `bluetooth.service` service

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo systemctl enable bluetooth.service
[I] dustvoice@DustArch ~
$ sudo systemctl start bluetooth.service
----

[NOTE]
====
To use `bluetoothctl` and get access to the Bluetooth device of your PC, your user needs to be a member of the `lp` group.
====

Now simply enter `bluetoothctl`

[source, console]
----
[I] dustvoice@DustArch ~
$ bluetoothctl
----

In most cases your Bluetooth interface will be preselected and defaulted, but in some cases, you might need to first select the Bluetooth controller

[source, console]
----
(insert) [DustVoice]# list
(insert) [DustVoice]# select <MAC_address>
----

After that, power on the controller

[source, console]
----
(insert) [DustVoice]# power on
----

Now enter device discovery mode

[source, console]
----
(insert) [DustVoice]# scan on
----

and list found devices

[source, console]
----
(insert) [DustVoice]# devices
----

[NOTE]
====
You can turn device discovery mode off again, after your desired device has been found

[source, console]
----
(insert) [DustVoice]# scan off
----
====

Now turn on the agent

[source, console]
----
(insert) [DustVoice]# agent on
----

and pair with your device

[source, console]
----
(insert) [DustVoice]# pair <MAC_address>
----

[NOTE]
====
If your device doesn't support PIN verification you might need to manually trust the device

[source, console]
----
(insert) [DustVoice]# trust <MAC_address>
----
====

Finally connect to your device

[source, console]
----
(insert) [DustVoice]# connect <MAC_address>
----

[NOTE]
====
If your device is an audio device, of some kind you might have to install `pulseaudio-bluetooth` and append 2 lines to `/etc/pulse/system.pa` as well.

So first install `pulseaudio-bluetooth`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S pulseaudio-bluetooth
----

append the following 2 lines

./etc/pulse/system.pa
[source, text]
----
load-module module-bluetooth-policy
load-module module-bluetooth-discover
----

and restart `pulseaudio`

[source, console]
----
[I] dustvoice@DustArch ~
$ pulseaudo --kill
[I] dustvoice@DustArch ~
$ pulseaudo --start
----

====

If you want a GUI to do all of this, just install `blueman` and launch `blueman-manager`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S blueman
----

=== Graphical desktop environment

If you decide, that you want to use a graphical desktop environment, you have to install additional packages in order for that to work.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S xorg xorg-xinit xorg-drivers i3 i3status rofi ttf-hack xfce4-terminal alsa alsa-utils arandr
----

==== NVIDIA

If you also want to use NVIDIA functionality, for example for `davinci-resolve`, you'll most likely need to install their proprietary driver

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S nvidia nvidia-utils nvidia-settings opencl-nvidia
----

[NOTE]
====
You would have to reboot sooner or later after installing the NVIDIA drivers.

Also to get the best performance, at least for something like screen capturing in `obs`, go to *X Server Display Configuration* inside `nvidia-settings`, switch to *Advanced* and enable *Force Composition Pipeline*, as well as *Force Full Composition Pipeline*.
====

==== Launching the graphical environment

After that you can now do `startx` in order to launch the graphical environment.

If anything goes wrong in the process, remember that you can press *Ctrl+Alt+<Number>* to switch ``tty``s.

===== The NVIDIA way

If you're using an NVIDIA graphics card, you might want to use `nvidia-xrun` instead of `startx`.
This has the advantage, of the `nvidia` kernel modules, as well as the `nouveau` ones not loaded at boot time, thus saving power.
`nvidia-xrun` will then load the correct kernel modules and run the `.nvidia-xinitrc` script in your home directory (for more file locations look into the documentation for `nvidia-xrun`).

[IMPORTANT]
====
At the time of writing, `nvidia-xrun` needs `sudo` permissions before executing its task.
====

Simply install `nvidia-xrun`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S nvidia bbswitch
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/nvidia-xrun.git
[I] dustvoice@DustArch ~
$ cd nvidia-xrun
[I] dustvoice@DustArch ~/nvidia-xrun
$ makepkg -si
[I] dustvoice@DustArch ~/nvidia-xrun
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf nvidia-xrun
----

[NOTE]
====
If your hardware doesn't support `bbswitch`, you would need to run

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S nvidia
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/nvidia-xrun-pm.git
[I] dustvoice@DustArch ~
$ cd nvidia-xrun-pm
[I] dustvoice@DustArch ~/nvidia-xrun-pm
$ makepkg -si
[I] dustvoice@DustArch ~/nvidia-xrun-pm
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf nvidia-xrun-pm
----

instead.
====

Now we need to blacklist *both `nouveau` and `nvidia`* kernel modules.

To do that, we first have to find out, where our active `modprobe.d` directory is located.
There are 2 possible locations, generally speaking: `/etc/modprobe.d` and `/usr/lib/modprobe.d`.
In my case it was the latter, which I could tell, because this directory already had files in it.

Now I'll create a new file named `nvidia-xrun.conf` and write the following into it

./usr/lib/modprobe.d/nvidia-xrun.conf
[source, text, linenums]
----
blacklist nvidia
blacklist nvidia-drm
blacklist nvidia-modeset
blacklist nvidia-uvm
blacklist nouveau
----

With this config in place,

[source, console]
----
[I] dustvoice@DustArch ~
$ lsmod | grep nvidia
----

and

[source, console]
----
[I] dustvoice@DustArch ~
$ lsmod | grep nouveau
----

should return no output.
Else you might have to place some additional entries into the file.

[NOTE]
====
Of course, you'll need to reboot, after blacklisting the modules and before issuing the 2 commands mentioned.
====

[NOTE]
====
If you installed `nvidia-xrun-pm` instead of `nvidia-xrun` and `bbswitch`, you might want to also enable the `nvidia-xrun-pm` service

[source, console]
----
[I] dustvoice@dustArch ~
$ sudo systemctl enable nvidia-xrun-pm.service
----
====

[NOTE]
====
The required `.nvidia-xinitrc` file, mentioned previously, should already be provided in the `dotfiles` repository.
====

Now instead of `startx`, just run `nvidia-xrun`, enter your `sudo` password and you're good to go.

=== GUI Software

As you now have a working graphical desktop environment, you might want to install some software to utilize your newly gained power.

==== Desktop background

You might want to consider installing `nitrogen`, in order to be able to set a background image

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S nitrogen
----

==== Compositing software

To get buttery smooth animation as well as e.g. smooth video playback in `brave` without screen tearing, you might want to consider using a compositor, in my case one named `picom`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S picom
----

Now edit the file `~/.config/i3/config` and uncomment the `picom` line in order to start `picom` with `i3`.

[WARNING]
====
In order for ``obs``' screen capture to work correctly, you need to kill `picom` completely before using `obs`.

[source, console]
----
[I] dustvoice@DustArch ~
$ pkill picom
----

or

[source, console]
----
[I] dustvoice@DustArch ~
$ ps aux | grep picom
[I] dustvoice@DustArch ~
$ kill -9 <pid>
----
====

==== `networkmanager` applet

To install the `NetworkManager` applet, which lives in your tray and provides you with a quick method to connect to different networks, you have to install the `network-manager-applet` package

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S network-manager-applet
----

Now you can start the applet with

[source, console]
----
[I] dustvoice@DustArch ~
$ nm-applet &
----

If you want to edit the network connections with a more full screen approach, you can also launch `nm-connection-editor`.

[NOTE]
====
The `nm-connection-editor` doesn't search for available Wi-Fis.
You would have to set up a Wi-Fi connection completely by hand, which could be desirable depending on how difficult to set up your Wi-Fi is.
====

==== Keyboard

To show, which keyboard layout and variant is currently in use, you can use `xkblayout-state`, which you can acquire from the `AUR`

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/xkblayout-state.git
[I] dustvoice@DustArch ~
$ cd xkblayout-state
[I] dustvoice@DustArch ~/xkblayout-state
$ makepkg -si
[I] dustvoice@DustArch ~/xkblayout-state
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf xkblayout-state
----

Now simply issue the `layout` alias, provided by our custom `fish` configuration.

==== X clipboard

To copy something from the terminal to the `xorg` clipboard, use `xclip`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S xclip
[I] dustvoice@DustArch ~
$ xclip some_random_text
----

==== Taking screen shots

For this functionality, especially in combination with `rofi`, use `scrot`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S scrot
----

`scrot ~/Pictures/filename.png` then saves the screen shot under `~/Pictures/filename.png`.

==== Image viewer

Now that we can create screen shots, we might also want to view those

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S ristretto
[I] dustvoice@DustArch ~
$ ristretto filename.png
----

==== File manager

You probably also want to use a file manager.
In my case, `thunar`, the `xfce` file manager, worked best.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S thunar
----

To also be able to `mount` removable drives, without being `root` or using `sudo`, and in order to have a GUI for mounting stuff, you would need to install `gigolo` and `gvfs`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S gigolo gvfs
----

===== Android file transfer

To furthermore enable the transfer of files between your PC and your android phone, you'll have to install `mtp` and `gvfs-mtp`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S libmtp gvfs-mtp
----

Now you should be able to see your phone inside either `thunar`, or `gigolo`.

If you want to access the android's file system from the command line, you will need to either install and use `simple-mtpfs`, or `adb`

====== `simple-mtpfs`

Install `simple-mtpfs`

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/simple-mtpfs.git
[I] dustvoice@DustArch ~
$ cd simple-mtpfs
[I] dustvoice@DustArch ~/simple-mtpfs
$ makepkg -si
[I] dustvoice@DustArch ~/simple-mtpfs
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf simple-mtpfs
----

edit `/etc/fuse.conf` to uncomment

./etc/fuse.conf
[source, text]
----
user_allow_other
----

and mount the android device

[source, console]
----
[I] dustvoice@DustArch ~
$ simple-mtpfs -l
[I] dustvoice@DustArch ~
$ mkdir ~/mnt
[I] dustvoice@DustArch ~
$ simple-mtpfs --device <number> ~/mnt -allow_other
----

and respectively unmount it

[source, console]
----
[I] dustvoice@DustArch ~
$ fusermount -u mnt
[I] dustvoice@DustArch ~
$ rmdir mnt
----

====== `adb`

Install `adb`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S adb
----

kill the `adb` server, if it is running

[source, console]
----
[I] dustvoice@DustArch ~
$ adb kill-server
----

[NOTE]
====
If the server is currently not running, `adb` will output an error with a `Connection refused` message.
====

Now connect your phone, unlock it and start the `adb` server

[source, console]
----
[I] dustvoice@DustArch ~
$ adb start-server
----

If the PC is unknown to the android device, it will display a confirmation dialog.
Accept it and ensure that the device was recognized

[source, console]
----
[I] dustvoice@DustArch ~
$ adb devices
----

Now you can ``push``/``pull`` files.

[source, console]
----
[I] dustvoice@DustArch ~
$ adb pull /storage/emulated/0/DCIM/Camera/IMG.jpg .
[I] dustvoice@DustArch ~
$ adb push IMG.jpg /storage/emulated/0/DCIM/Camera/IMG2.jpg
[I] dustvoice@DustArch ~
$ adb kill-server
----

[NOTE]
====
Of course you would need to have the _developer options_ unlocked, as well as the _USB debugging_ option enabled within them, for `adb` to even work.
====

==== Archive manager

As we now have a file manager, it might be annoying, to open up a terminal every time you simply want to extract an archive of some sort.
That's why we'll install `xarchiver`.

In order for `xarchiver` to work at its full potential, we're first gonna install some additional archive types

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S p7zip zip unrar cpio
----

Now we can proceed to install `xarchiver`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S xarchiver
----

==== Partition management

You may also choose to use a graphical partitioning software instead of `fdisk` or `cfdisk`.
For that you can install `gparted`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S gparted
----

==== PDF viewer 

As we've installed `asciidoctor-pdf` previously, you might be wondering how you are supposed to open the generated PDFs.
There are two ways.

===== Using the GUI

Installing `mupdf` is as simple as issuing

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S mupdf
----

If you want to have changes made to the PDF reflected immediately in the viewer, you would need `evince` instead

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S evince
----

===== Using the framebuffer

If you want to not always use the graphical desktop with `mupdf`, you might be interested in the `fbgs` software.

This software renders a PDF document using the native framebuffer.
To install it simply do

[source, console]
----
[I] dustvoice@DustArch ~
$ pacman -S fbida ghostscript
----

and to view this PDF document (`Documentation.pdf`) for example, you would run

[source, console]
----
[I] dustvoice@DustArch ~
$ fbgs Documentation.pdf
----

[INFO]
====
You can view all the controls by pressing `h`.
====

==== Web browser

As you're already using a GUI, you also might be interested in a web browser.
In my case, I'll install `brave` from the `AUR`, as well as `browserpass` from the official repositories, in order to use my passwords in `brave`.

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/brave-bin.git
[I] dustvoice@DustArch ~/brave-bin
$ makepkg -si
[I] dustvoice@DustArch ~/brave-bin
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf brave-bin
[I] dustvoice@DustArch ~
$ sudo pacman -S browserpass
----

Now we still have to setup `browserpass`

[source, console]
----
[I] dustvoice@DustArch ~
$ cd /usr/local/lib/browserpass
[I] dustvoice@DustArch /usr/local/lib/browserpass
$ make hosts-brave-user
[I] dustvoice@DustArch /usr/local/lib/browserpass
$ make policies-brave-user
[I] dustvoice@DustArch /usr/local/lib/browserpass
$ cd ~
----

Now the only thing left is, to fire up `brave` and install the `browserpass` extension from the chrome store.

===== Entering the dark side

You might want to be completely anonymous whilst browsing the web at some point.
Although this shouldn't be your only precaution, using `tor-browser` would be the first thing to do

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/tor-browser.git
[I] dustvoice@DustArch ~
$ cd tor-browser
[I] dustvoice@DustArch ~/tor-browser
$ makepkg -si
[I] dustvoice@DustArch ~/tor-browser
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf tor-browser
----

==== Office utilities

For now we'll install `libreoffice-fresh`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S libreoffice-fresh
----

===== Printing

In order for printing to work with my printer, I had to install `avahi`, `cups`, `cups-pdf`, `nss-mdns` and the correspoding driver for my printer.
In order to be able to print from the `gtk` print dialog, we'll also need to install `system-config-printer` and `print-manager`.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S avahi
[I] dustvoice@DustArch ~
$ sudo pacman -S cups cups-pdf nss-mdns
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/brother-mfc-j497dw.git
[I] dustvoice@DustArch ~
$ cd brother-mfc-j497dw
[I] dustvoice@DustArch ~/brother-mfc-j497dw
$ makepkg -si
[I] dustvoice@DustArch ~/brother-mfc-j497dw
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf brother-mfc-j497dw
[I] dustvoice@DustArch ~
$ sudo systemctl enable avahi-daemon.service
[I] dustvoice@DustArch ~
$ sudo systemctl start avahi-daemon.service
----

Now you have to edit `/etc/nsswitch.conf`

so this line

./etc/nsswitch.conf
[source, text]
----
hosts: files mymachines myhostname resolve [!UNAVAIL=return] dns
----

becomes this line

./etc/nsswitch.conf
[source, text]
----
hosts: files mymachines myhostname mdns4_minimal [NOTFOUND=return] resolve [!UNAVAIL=return] dns
----

Now continue with this

[source, console]
----
[I] dustvoice@DustArch ~
$ avahi-browse --all --ignore-local --resolve --terminate
[I] dustvoice@DustArch ~
$ sudo systemctl enable org.cups.cupsd.service
[I] dustvoice@DustArch ~
$ sudo systemctl start org.cups.cupsd.service
[I] dustvoice@DustArch ~
$ sudo pacman -S system-config-printer print-manager
----

Just open up `system-config-printer` now and configure your printer.

To test if everything is working, you could open up `brave`, then go to *Print* and then try printing.

==== Process management

The native tool is `top`.

The next evolutionary step would be `htop`, which is an improved version of `top` (like `vi` and `vim` for example)

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S htop
----

If you prefer a GUI for that kind of task, install `xfce4-taskmanager`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S xfce4-taskmanager
----

==== Communication

Life is all about communicating.
Here are some pieces of software to do exactly that.

===== Email

There is nothing better than some classical email.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S thunderbird
----

===== Telegram

You want to have your `telegram` messages on your desktop PC?

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S telegram-desktop
----

===== TeamSpeak 3

Wanna chat with your gaming friends and they have a `teamspeak3` server?
Go for it

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S teamspeak3
----

===== Discord

You'd rather use `discord`?
No problem

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S discord
----

==== Video software

Just some additional software related to videos.

===== Viewing video

You might consider using `vlc`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S vlc
----

===== Creating video

`obs` should be the right choice

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/obs-studio-git
[I] dustvoice@DustArch ~
$ cd obs-studio-git
[I] dustvoice@DustArch ~/obs-studio-git
$ makepkg -si
[I] dustvoice@DustArch ~/obs-studio-git
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf obs-studio-git
----

====== Showing keystrokes

In order to show the viewers what keystrokes you're pressing, you can use something like `screenkey`

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/screenkey.git
[I] dustvoice@DustArch ~
$ cd screenkey
[I] dustvoice@DustArch ~/screenkey
$ makepkg -si
[I] dustvoice@DustArch ~/screenkey
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf screenkey
[I] dustvoice@DustArch ~
$ screenkey
----

[NOTE]
====
For ideal use with `obs`, my `dotfiles` repository already provides you with the `screenkey-obs` script for you to run with `fish`.
====

===== Live stream a terminal session

For this task, you'll need a program called `tmate`.
Just install

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S tmate
----

and run it

[source, console]
----
[I] dustvoice@DustArch ~
$ tmate
----

===== Editing video

In my case, I'm using `davinci-resolve`.

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/davinci-resolve.git
[I] dustvoice@DustArch ~
$ cd davinci-resolve
[I] dustvoice@DustArch ~/davinci-resolve
$ makepkg -si
[I] dustvoice@DustArch ~/davinci-resolve
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf davinci-resolve
----

===== Utilizing video

Wanna remote control your own or another PC?
`teamviewer` might just be the right choice for you

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/teamviewer.git
[I] dustvoice@DustArch ~
$ cd teamviewer
[I] dustvoice@DustArch ~/teamviewer
$ makepkg -si
[I] dustvoice@DustArch ~/teamviewer
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf teamviewer
----

==== Ardour

To e.g. edit and produce audio, I would recommend `ardour`, because it's easy to use, stable and cross platform.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S ardour
----

[NOTE]
====
You might have to edit `/etc/security/limits.conf`, to increase the allowed locked memory amount.

In my case I have 32GB of RAM and I want the `audio` group to be allocate most of the RAM, which is why I added the following line to the file

./etc/security/limits.conf
[source, text]
----
@audio - memlock 29360128
----
====

[INFO]
====
Ardour won't natively save in the `mp3` format, due to licensing stuff.
In order to create `mp3` files, for sharing with other devices, because they have problems with `wav` files, for example, you can just use `ffmpeg`.

First make sure it's installed

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S ffmpeg
----

and after that we're going to convert `in.wav` to `out.mp3`

[source, console]
----
[I] dustvoice@DustArch ~
$ ffmpeg -i in.wav -acodec mp3 out.mp3
----
====

==== Virtualization

You might need to run another OS, for example Mac OS, from within Linux, e.g. for development/testing purposes.
For that you can use `virtualbox`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S virtualbox virtualbox-host-modules-arch
----

Now when you want to use `virtualbox` just load the kernel module

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo modprobe vboxdrv
----

and add the user which is supposed to run `virtualbox` to the `vboxusers` group

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo usermod -a G vboxusers $USER
----

and if you want to use `rawdisk` functionality, also to the `disk` group

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo usermod -a G disk $USER
----

Now just re-login and you're good to go.

// Longterm TODO: After getting a system with 2 GPUs, add part for KVMing a Windows.
// Resources:
// - virt-manager
// - wiki.archlinux.org/index.php/KVM
// - wiki.debian.org/VGAPassthrough
// - ycnrg.org/vga-passthrough-with-ovmf-vfio
// - bufferoverflow.io/gpu-passthrough
// - heiko-sieger.info/running-windows-10-on-linux-using-kvm-with-vga-passthrough
// - openwebit.com/c/how-to-run-windows-vm-on-more-than-2-cores-under-kvm

==== Gaming

The first option for native/emulated gaming on Linux is obviously `steam`.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S steam lib32-nvidia-utils pulseaudio pulseaudio-alsa lib32-libpulse
----

The second option would be `lutris`, a program, that configures a wine instance correctly, etc.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S lutris
----

==== Wacom

In order to use a Wacom graphics tablet, you'll have to install some packages

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S libwacom xf86-input-wacom
----

You could now configure your tablet using the `xsetwacom` command.
But on the other hand there is also `wacom-utility`, a GUI software for all of that, so you could try if that works first.

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/wacom-utility.git
[I] dustvoice@DustArch ~
$ cd wacom-utility
[I] dustvoice@DustArch ~/wacom-utility
$ git clone https://aur.archlinux.org/gksu.git
[I] dustvoice@DustArch ~/wacom-utility
$ cd gksu
[I] dustvoice@DustArch ~/wacom-utility/gksu
$ git clone https://aur.archlinux.org/libgks.git
[I] dustvoice@DustArch ~/wacom-utility/gksu
$ cd libgks
[I] dustvoice@DustArch ~/wacom-utility/gksu/libgks
$ makepkg -si
[I] dustvoice@DustArch ~/wacom-utility/gksu/libgks
$ cd ..
[I] dustvoice@DustArch ~/wacom-utility/gksu
$ makepkg -si
[I] dustvoice@DustArch ~/wacom-utility/gksu
$ cd ..
[I] dustvoice@DustArch ~/wacom-utility
$ makepkg -si
[I] dustvoice@DustArch ~/wacom-utility
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf wacom-utility
----

== Upgrading the system

You're probably wondering why this gets a dedicated section.

You'll probably think that it would be just a matter of issuing

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -Syu
----

That's both true and false.

You have to make sure, *that your boot partition is mounted at `/boot`* in order for everything to upgrade correctly.
That's because the moment you upgrade the `linux` package without having the correct partition mounted at `/boot`, your system won't boot.
You also might have to do `grub-mkconfig -o /boot/grub/grub.cfg` after you install a different kernel image.

If your system *indeed doesn't boot* and *boots to a recovery console*, then double check that the issue really is the not perfectly executed kernel update by issuing

[source, console]
----
[I] root@DustArch ~
$ uname -a
----

and

[source, console]
----
[I] root@DustArch ~
$ pacman -Q linux
----

*The version of these two packages should be exactly the same!*

If it isn't there is an easy fix for it.

=== Fixing a faulty kernel upgrade

First off we need to restore the old `linux` package.

For that note the version number of

[source, console]
----
[I] root@DustArch ~
$ uname -a
----

Now we'll make sure first that nothing is mounted at `/boot`, because the process will likely create some unwanted files.
The process will also create a new `/boot` folder, which we're going to delete afterwards.

[source, console]
----
[I] root@DustArch ~
$ umount /boot
----

Now `cd` into ``pacman``'s package cache

[source, console]
----
[I] root@DustArch ~
$ cd /var/cache/pacman/pkg
----

There should be a file located named something like `linux-<version>.pkg.tar.xz`, where `<version>` would be somewhat equivalent to the previously noted version number

Now downgrade the `linux` package

[source, console]
----
[I] root@DustArch ~
$ pacman -U linux-<version>.pkg.tar.xz
----

After that remove the possibly created `/boot` directory

[source, console]
----
[I] root@DustArch ~
$ rm -rf /boot
[I] root@DustArch ~
$ mkdir /boot
----

Now reboot and `mount` the `boot` partition, in my case an `EFI System Partition`.

Now simply rerun

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -Syu
----

and you should be fine now.

[NOTE]
====
Consider setting up a `fstab` entry for the `boot` partition, in order to avoid such dilemma in the future.

See <<setting-up-fstab>> for more.
====

== `DustArch` package list

A complete list of all the packages present on my full fledged system at the time of writing

..packages-x86_64
[source, text, linenums]
----
include::.packages-x86_64[]
----
