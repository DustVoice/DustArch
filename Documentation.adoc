= DustArch: DustVoice's Arch Linux from scratch
David Holland <info@dustvoice.de>
v3.2, 2019-12-19
:toc: left
:toc-title: Table Of Contents
:toclevels: 4
:doctype: book
:docinfo: shared
:source-highlighter: pygments
:icons: font
:last-update-label: Last modified:
:table-caption!:

== Inside the `archiso`

This section is aimed at providing help with the general installation of the customized archlinux from within official archlinux image.

=== Updating the system

First of we need to sync pacman up

[source, console]
----
root@archiso ~ # pacman -Sy
----

[NOTE]
====
After that, you will now be able to install packages with pacman.
====

=== Formatting the drive

First you have to list all the available drives by issuing

[source, console]
----
root@archiso ~ # fdisk -l
----

[NOTE]
====
The output of `fdisk -l` is dependent on your system configuration.
====

In my case, the partition I want to install the root filesystem on is `/dev/sdb2`.
`/dev/sdb3` will be my swap partition.

[NOTE]
====
A swap size twice the size of your RAM is recommended by a lot of people.
You should make the swap size *at least your RAM size* though.
====

[IMPORTANT]
====
If you haven't yet partitioned your disk, please refer to a general partitioning tutorial in the arch-wiki.
====

Now we need to format the partitions accordingly

[source, console]
----
root@archiso ~ # mkfs.ext4 /dev/sdb2
root@archiso ~ # mkswap /dev/sdb3
----

After doing that, we can enable the swap and mount the root partition.

[source, console]
----
root@archiso ~ # swapon /dev/sdb3
root@archiso ~ # mount /dev/sdb2 /mnt
----

[NOTE]
====
If you have an additional *EFI system partition*, because of a _UEFI - GPT_ setup or e.g. an existing Windows installation, which we will assume to be located under `/dev/sda2` (`/dev/sda` is the disk of my Windows install), you'll have to mount this partition to the new systems `/boot` folder

[source, console]
----
root@archiso ~ # mkdir /mnt/boot
root@archiso ~ # mount /dev/sda2 /mnt/boot
----
====

=== Preparing the `chroot` environment

First it might make sense to edit `/etc/pacman.d/mirrorlist` to move the mirror(s) geographically closest to you to the top.

After that we can either install the bare minimum packages needed

[source, console]
----
root@archiso ~ # pacstrap /mnt base linux linux-firmware
----

or install all packages present on the archiso, which makes sense in our case

[source, console]
----
root@archiso ~ # pacstrap /mnt base base-devel linux linux-firmware $(pacman -Qq | tr '\n' ' ')
----

This could take quite some time depending on your internet connection speed.

After that generate a `fstab` using `genfstab`

[source, console]
----
root@archiso ~ # genfstab -U /mnt >> /mnt/etc/fstab
----

and you're ready to go entering the chroot environment.

=== Entering the `chroot`

[source, console]
----
root@archiso ~ # arch-chroot /mnt
----

Et voila, you're inside the new os, greeted by a bash prompt.

==== Installing additional packages

First off you'll probably need an editor.
I'll use `neovim`

[source, console]
----
[root@archiso /]# pacman -S neovim
----

After that we'll make sure we get ourselves some basic utilities and enable the `NetworkManager.service` service, in order for the internet connection to work upon booting in our fresh system later.

[source, console]
----
[root@archiso /]# pacman -S sudo iputils dhcpcd dhclient grub dosfstools os-prober mtools networkmanager networkmanager-openvpn networkmanager-openconnect
[root@archiso /]# systemctl enable NetworkManager.service
----

Furthermore you'll also need to make sure `polkit` is installed

[source, console]
----
[root@archiso /]# pacman -S polkit
----

and then create a file `/etc/polkit-1/rules.de/50-org.freedesktop.NetworkManager.rules` to enable users of the `network` group to add new networks without `sudo`.

./etc/polkit-1/rules.de/50-org.freedesktop.NetworkManager.rules
[source, text]
----
polkit.addRule(function(action, subject) {
    if (action.id.indexOf("org.freedesktop.NetworkManager.") == 0 && subject.isInGroup("network")) {
        return polkit.Result.YES;
    }
});
----

If you use `UEFI`, you'll also need

[source, console]
----
[root@archiso /]# pacman -S efibootmgr
----

==== Changing the keyboard layout

The next thing you probably wanna do, at least if you're me, is to change the keyboard layout.
In my case I'll adapt the standard `us` layout, so the `Caps_Lock` key will be mapped to `Escape`.

`Neovim` saves me from a ton of headaches, by providing the functionality to edit `gzip` files directly.

In my case I'll copy the `us` and `us-acentos` to `custom-us` and `custom-us-acentos` respectively

[source, console]
----
[root@archiso /]# cp /usr/share/kbd/keymaps/i386/qwerty/us.map.gz /usr/share/kbd/keymaps/i386/qwerty/custom-us.map.gz
[root@archiso /]# cp /usr/share/kbd/keymaps/i386/qwerty/us-acentos.map.gz /usr/share/kbd/keymaps/i386/qwerty/custom-us-acentos.map.gz
----

and change the line

./usr/share/kbd/keymaps/i386/qwerty/custom-us.map.gz
[source, text]
----
keycode 58 = Caps_Lock
----

to

./usr/share/kbd/keymaps/i386/qwerty/custom-us.map.gz
[source, text]
----
keycode 58 = Escape
----

in both created files.

Now you are able to load the keymap and set it as the default one to use respectively

[source, console]
----
root@archiso ~ # loadkeys custom-us
root@archiso ~ # localectl set-keymap custom-us
----

==== Master of time

After that you have to set your timezone and update the system clock.
Generally speaking, you can find all the different timezones under `/usr/share/zoneinfo`.
For me it is `/usr/share/zoneinfo/Europe/Berlin` and I had to issue

[source, console]
----
[root@archiso /]# ln -s /usr/share/zoneinfo/Europe/Berlin /etc/localtime
[root@archiso /]# hwclock --systohc --utc
----

Now you can also enable time synchronization over network and check that everything is alright

[source, console]
----
[root@archiso /]# timedatectl set-timezone Europe/Berlin
[root@archiso /]# timedatectl set-ntp true
[root@archiso /]# timedatectl status
----

==== Master of locales

After that you have to generate your locale information.
For that you have to edit `/etc/locale.gen` and uncomment the locale lines you want to enable.
I recommend to always uncomment `en_US.UTF-8 UTF8` for development purposes, even if you want to use another language primarily.
In my case I uncommented

./etc/locale.gen
[source, text]
----
[...]
#en_US.UTF-8 UTF8
[...]
----

which then became

./etc/locale.gen
[source, text]
----
[...]
en_US.UTF-8 UTF8
[...]
----

After that you still have to actually generate the locales by issuing

[source, console]
----
[root@archiso /]# locale-gen
----

and set the locale

[source, console]
----
[root@archiso /]# localectl set-locale LANG="en_US.UTF-8"
----

and we're done with this part.

==== Naming your machine

Now we can set the `hostname` and add `hosts` entries.

===== `hostname`

To change the `hostname`, simply edit `/etc/hostname`, enter the desired name, then save and quit.

[source, console]
----
[root@archiso /]# nvim /etc/hostname
----

which in my case then cointains

./etc/hostname
[source, text]
----
DustArch
----

===== `hosts`

Now we need to specify some `hosts` entries by editing `/etc/hosts`

[source, console]
----
[root@archiso /]# nvim /etc/hosts
----

And originall looked like this

./etc/hosts
[source, text]
----
# Static table lookup for hostnames.
# See hosts(5) for details.
----

and now looks like this

./etc/hosts
[source, text]
----
# Static table lookup for hostnames.
# See hosts(5) for details.

127.0.0.1   localhost           .
::1         localhost           .
127.0.1.1   DustArch.localhost  DustArch
----

==== User setup

Now you should probably change the default root password and create a new user for yourself, as using your new system purley through the native root user is not recommended from a security standpoint.

===== Give `root` a password

To change the password for the current user (the root user) do

[source, console]
----
[root@archiso /]# passwd
----

and choose a new password.

[#creating-my-personal-user]
===== Creating my personal user

We are going to make sure the `fish` shell is installed, create a new user, set the password for this user, make sure the `sudo` package is installed and allow the `wheel` group sudo access.

[source, console]
----
[root@archiso /]# pacman -S fish
[root@archiso /]# useradd -m -p "" -G "adm,audio,floppy,kvm,log,lp,network,rfkill,scanner,storage,users,optical,power,wheel" -s /usr/bin/fish dustvoice
[root@archiso /]# passwd dustvoice
[root@archiso /]# pacman -S sudo
----

We now have to allow the `wheel` group sudo access.
For that we edit

[source, console]
----
[root@archiso /]# sudo nvim /etc/sudoers
----

and uncomment the following line

./etc/sudoers
[source, text]
----
## Uncomment to allow members of group wheel to execute any command
# %wheel ALL=(ALL) ALL
----

so that it becomes the following

./etc/sudoers
[source, text]
----
## Uncomment to allow members of group wheel to execute any command
%wheel ALL=(ALL) ALL
----

You could also add a new line below

./etc/sudoers
[source, text]
----
root ALL=(ALL) ALL
----

with your new username

./etc/sudoers
[source, text]
----
dustvoice ALL=(ALL) ALL
----

to solely grant yourself sudo privileges.

=== Preparing to boot

Now onto installing the boot manager.
We will use `grub` in this guide.

First make sure, all the required packages are installed

[source, console]
----
[root@archiso /]# pacman -S grub dosfstools os-prober mtools
----

and if you want to use `UEFI`, also

[source, console]
----
[root@archiso /]# pacman -S efibootmgr
----

==== `BIOS`

If you chose the `BIOS - MBR` variation, have to do nothing special

If you chose the `BIOS - GPT` variation, you'll have to have a `+1M` boot partition created with the partition type set to `BIOS boot` for `fdisk`.

In both cases you now have to run the following command

[source, console]
----
[root@archiso /]# grub-install --target=i386-pc /dev/sdb
----

[NOTE]
====
It is obvious, you have to replace `/dev/sda` with the disk you want to use.
Note however that you have to specify a *disk* and *not a partition*, so *no number*.
====

==== `UEFI`

If you chose the `UEFI - GPT` variation, you'll have to have the `EFI System Partition` mounted (where `/dev/sda2` is the partition holding said `EFI System Partition` in my particular setup) and execute the following command

[source, console]
----
[root@archiso /]# grub_install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub --recheck
----

[IMPORTANT]
====
If you've planned on dual booting arch with Windows and therefore reused the `EFI System Partition` created by Windows, you might not be able to boot to grub just yet.
In this case, boot into Windows, open a `cmd` window as administrator and type in

[source, console]
----
bcdedit /set {bootmgr} path \EFI\grub\grubx64.efi
----

To make sure that the path is correct, you can just

[source, console]
----
[root@archiso /]# ls /boot/EFI/grub
----

to make sure, that the `grubx64.efi` file is really there.

Now you should be good to go.
====

==== `grub` config

In all cases, you now have to create the main configuration file

[source, console]
----
[root@archiso /]# grub-mkconfig -o /boot/grub/grub.cfg
----

Now you're good to boot into your new system

== Inside the `DustArch`

=== Someone there?

First we have to check if the network interfaces are set up properly

[source, console]
----
dustvoice@DustArch ~> ip link
----

This outputs the interface status report.
To make sure that you really have a working _internet_ connection, issue

[source, console]
----
dustvoice@DustArch ~> ping archlinux.org
----

Everything should run smoothly if you have a wired connection.
If there is still no connection try restarting the `NetworkManager.service` service

[source, console]
----
dustvoice@DustArch ~> sudo systemctl restart NetworkManager.service
----

and then try `ping` again.

If you're indeed trying to utilize a WiFi connection, use `nmcli`, the `NetworkManager` command line tool, or `nmtui`, the `NetworkManager` terminal ui, to connect to a WiFi network.

First make sure, that our WiFi `radio` is up and running

[source, console]
----
dustvoice@DustArch ~> nmcli radio
----

Now make sure your WiFi interface appears under

[source, console]
----
dustvoice@DustArch ~> nmcli d
----

Rescan for available networks

[source, console]
----
dustvoice@DustArch ~> nmcli d wifi rescan
----

and list all found networks

[source, console]
----
dustvoice@DustArch ~> nmcli d wifi list
----

After that connect to the network

[source, console]
----
dustvoice@DustArch ~> nmcli --ask d wifi connect <SSID> password wireless-password
----

Now try ``ping``ing again.



=== Update and upgrade

After making sure that you have established an internet connection, you can then proceed to update and upgrade all installed packages by issuing

[source, console]
----
dustvoice@DustArch ~> sudo pacman -Syu
----

=== Setting the correct shell

I'll be using the `fish` shell.

We already set the correct shell for the `dustvoice` user in the <<creating-my-personal-user>> step, but I want to use `fish` for the `root` user too, so I'll have to change ``root``'s default shell to it.

[source, console]
----
dustvoice@DustArch ~> chsh -s /usr/bin/fish root
----

Don't worry about the looks by the way, we're gonna change all that in just a second.

=== Version control

Next you'll probably want to install `git`.
Just do

[source, console]
----
dustvoice@DustArch ~> sudo pacman -S git
----

and you're good to go.
We'll care about the `.gitconfig` in just a second.

=== Security is important

If you've followed the tutorial using a recent version of arch linux, you'll probably already have the most recent version of `gnupg` installed by default.
Just to make sure, issue

[source, console]
----
dustvoice@DustArch ~> sudo pacman -S gnupg
----

==== Smartcard shenanigans

After that you'll still have to setup `gnupg` correctly.
In my case I have my private keys stored on a smartcard.
To use it, I'll have to install some packages first

[source, console]
----
dustvoice@DustArch ~> sudo pacman -S pcsclite libusb-compat ccid opensc
----

and then enable and start the `pcscd` service

[source, console]
----
dustvoice@DustArch ~> sudo systemctl enable pcscd.service
dustvoice@DustArch ~> sudo systemctl start pcscd.service
----

Note however that your mileage may vary.

[#additional-tools-setup-home]
=== Additional required tools

[source, console]
----
dustvoice@DustArch ~> pacman -S make cmake clang jdk-openjdk pyhton pyhton-pip pass openssh
----

[#setup-home]
=== Setting up a `home` environment

In this step we're going to setup a home environment for both the `root` and my personal `dustvoice` user.

[NOTE]
====
In my case these 2 home environments are mostly equivalent, which is why I'll execute the follwing commands as the `dustvoice` user first and then `su` into the `root` user and repeat the same commands.
====

[NOTE]
====
In my case, I want to access all my git repositories with my `gpg` key on my smartcard.
For that I have to configure the `gpg-agent` though.
So I will have to reside to first use the `https` url and later change the url in the corresponding `.git/config` file.
====

[source, console]
----
dustvoice@DustArch ~> git init
dustvoice@DustArch ~> git remote add origin https://github.com/DustVoice/dotfiles.git
dustvoice@DustArch ~> git fetch
dustvoice@DustArch ~> git reset origin/master --hard
dustvoice@DustArch ~> git branch --set-upstream-to=origin/master master
----

Before we'll be able to update the ``submodule``s (`nvim` config files and ``pass``word-store), we will have to setup our `gpg` key as a `ssh` key

[source, console]
----
[I] dustvoice@DustArch ~>
$ chmod 700 .gnupg
[I] dustvoice@DustArch ~>
$ gpg --card-status
[I] dustvoice@DustArch ~>
$ gpg --card-edit
(insert) gpg/card> fetch
(insert) gpg/card> q
[I] dustvoice@DustArch ~>
$ gpg-connect-agent updatestartuptty /bye
[I] dustvoice@DustArch ~>
$ git remote set-url origin git@github.com:DustVoice/dotfiles.git
[I] dustvoice@DustArch ~>
$ exit
----

[NOTE]
====
You would have to adapt the keygrip present in the sshcontrol file to your keygrip, retrieved with `gpg -K --with-keygrip`.
====

Now log back in and continue

[source, console]
----
[I] dustvoice@DustArch ~
$ git submodule update --init --recursive
[I] dustvoice@DustArch ~
$ cd .config/nvim
[I] dustvoice@DustArch ~/.config/nvim
$ echo 'let g:platform = "linux"' >> platform.vim
[I] dustvoice@DustArch ~/.config/nvim
$ echo 'let g:use_autocomplete = 3' >> custom.vim
[I] dustvoice@DustArch ~/.config/nvim
$ echo 'let g:use_clang_format = 1' >> custom.vim
[I] dustvoice@DustArch ~/.config/nvim
$ echo 'let g:use_font = 0' >> custom.vim
[I] dustvoice@DustArch ~/.config/nvim
$ pip3 install neovim
[I] dustvoice@DustArch ~/.config/nvim
$ nvim --headless +PlugInstall +qa
[I] dustvoice@DustArch ~/.config/nvim
$ cd plugged/YouCompleteMe
[I] dustvoice@DustArch ~/.config/nvim/plugged/YouCompleteMe
$ python3 install.py --clang-completer --java-completer
[I] dustvoice@DustArch ~/.config/nvim/plugged/YouCompleteMe
$ cd ~
----

Your personal environment will be complete, after getting `JUCE` and `FRUT`

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://github.com/WeAreROLI/JUCE.git
[I] dustvoice@DustArch ~
$ cd JUCE
[I] dustvoice@DustArch ~/JUCE
$ git checkout develop
[I] dustvoice@DustArch ~/JUCE
$ cd ..
[I] dustvoice@DustArch ~
$ git clone https://github.com/McMartin/FRUT.git
----

[NOTE]
====
As mentioned before, you would now switch to the `root` user, either by logging in as root, or ``su``ing, and go back to <<setup-home>> to repeat all commands for the root user.
====

=== Password management

I'm using `pass` as my password manager.
We already installed it in the <<additional-tools-setup-home>> step.

=== `python`

Python has become really important for a magnitude of use cases.
We need `python3` in particular as well as the `pip` for it.
For `asciidoctor` _(will be installed in just a second)_ we also need to install the `pygments` package.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S python python-pip
[I] dustvoice@DustArch ~
$ sudo pip3 install pygments
----

=== `ruby` & `asciidoctor`

In order to use `asciidoctor`, we have to install `ruby` and `rubygems`.
After that we can install `asciidoctor` and all it's required gems.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S ruby rubygems
[I] dustvoice@DustArch ~
$ gem install asciidoctor --pre
[I] dustvoice@DustArch ~
$ gem install asciidoctor-pdf --pre
[I] dustvoice@DustArch ~
$ gem install asciidoctor-epub3 --pre
[I] dustvoice@DustArch ~
$ gem install pygments.rb --pre
----

Now the only thing left (in my case) is adding `~/.gem/ruby/2.6.0/bin` to your path.
For `fish` you'll want to run the following command

[source, console]
----
[I] dustvoice@DustArch ~
$ set -U fish_user_paths $fish_user_paths ~/.gem/ruby/2.6.0/bin
----

[NOTE]
====
If you use another shell than `fish`, you might have to do something different to add a directory to your `PATH`.

Also please note that if you run a ruby version different from `2.6.0`, you have to use the `bin` path for that version.
====

=== Using `JUCE`

In order to use `JUCE`, you'll need to have some dependency packages installed

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S clang gcc freeglut alsa-lib gnutls libcurl-gnutls freetype2 jack2 libx11 libxcomposite libxinerama libxrandr mesa webkit2gtk
----

If you want to use every feature of `JUCE` you'll need to install 2 more packages

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S ladspa lib32-freeglut
----

=== Additional development tools

Here are just some examples of development tools one could install in addition to what we already have.

==== Code formatting

We already have `clang-format` as a code formatter, but this only works for `C` languages.
For the `java` part, we can use `astyle`.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S astyle
----

==== Documentation

To generate a documentation from source code, I mostly use `doxygen`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S doxygen
----

==== Build tools

In addition to `make`, I'll often times use `ninja` for my builds

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S ninja
----

[#setting-up-fstab]
=== `fstab`

In my case, I'm sharing an `exFat` partition between my `DustArch` and my Windows.
This was a result of some major inconvenience because of some weird `NTFS` permission stuff, which apparently Windows didn't like.
Since I've avoided directly writing to Windows partitions since then, I'll quickly demonstrate what `fstab` entries I have and why

./etc/fstab
[source, text, linenums]
----
UUID=e26de048-6147-42e5-a34b-59f1a50621bb       /               ext4            rw,relatime             0 1

UUID="C8E3-A0FD"                                /boot           vfat            defaults                0 1

UUID="DC88-5A4E"                                /mnt/projects   exfat           rw,relatime             0 0

UUID=7A16569B51903310                           /mnt/data       ntfs            ro,nosuid,nodev,noauto  0 0
----

The first entry should be pretty straight forward.
It's my root partition of my `DustArch` install.

The second entry is quite important too.
It's my `EFI System Partition`, which get's mounted at boot time, in order to prevent kernel orphaning, which means, that the kernel version installed on the system doesn't match the one on the `boot` partition.

The third entry is my shared `exFat` partition, which we are allowed to write to.

The fourth entry is important, because of the options.
These options prevent me from modifying files on that `NTFS` partition.

=== Audio

Well, why wouldn't you want audio...

==== `alsa`

To quickly setup audio, install `alsa` and `alsa-utils`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S alsa alsa-utils
----

Now choose the soundcard you want to use

[source, console]
----
[I] dustvoice@DustArch ~
$ cat /proc/asound/cards
----

and then create `/etc/asound.conf`

./etc/asound.conf
[source, text]
----
defaults.pcm.card 2
defaults.ctl.card 2
----

[NOTE]
====
It should be apparent, that you would have to switch out `2` witht the number corresponding to the soundcard you want to use.
====

==== `pulseaudio`

Some applications require `pulseaudio` or work better with it (for example `discord`), so it might make sense to use `pulseaudio`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S pulseaudio pulsemixer
----

For enabling realtime priority for `pulseaudio` on arch, please make sure your user is part of the `audio` group and edit the file `/etc/pulse/daemon.conf` so that you uncomment the lines

[source, text]
----
; high-priority = yes
; nice-level = -11

; realtime-scheduling = yes
; realtime-priority = 5
----

to

[source, text]
----
high-priority = yes
nice-level = -11

realtime-scheduling = yes
realtime-priority = 5
----

If your system can handle the load, you can also increase the remixing quality, by changing

[source, text]
----
; resample-method = speex-float-1
----

to

[source, text]
----
resample-method = speex-float-10
----

Of course a restart of the `pulseaudio` daemon is mandatory.

[source, console]
----
[I] dustvoice@DustArch ~
$ pulseaudio --kill
[I] dustvoice@DustArch ~
$ pulseaudio --start
----

==== Audio handling

To also play audio, for example we need to install some other packages too

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S soc libao libmad libid3tag wavpack libpulse opus file twolame
----

Now you can simply do

[source, console]
----
[I] dustvoice@DustArch ~
$ play audio.wav
[I] dustvoice@DustArch ~
$ play audio.mp3
----

etc. to play audio.

=== Bluetooth

To set up bluetooth, we need to install the `bluez` and `bluez-util` packages in order to have at least a command line utility `bluetoothctl` to configure connections

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S bluez bluez-utils
----

Now we need to check if the `btusb` kernel module was already loaded

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo lsmod | grep btusb
----

After that we'll enable and start the `bluetooth.service` service

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo systemctl enable bluetooth.service
[I] dustvoice@DustArch ~
$ sudo systemctl start bluetooth.service
----

[NOTE]
====
To use `bluetoothctl` and get access to the bluetooth device of your pc, your user needs to be a member of the `lp` group.
====

Now simply enter `bluetoothctl`

[source, console]
----
[I] dustvoice@DustArch ~
$ bluetoothctl
----

In most cases your bluetooth interface will be pre-selected and defaulted, but in some cases, you might need to first select the bluetooth controller

[source, console]
----
(insert) [DustVoice]# list
(insert) [DustVoice]# select <MAC_address>
----

After that, power on the controller

[source, console]
----
(insert) [DustVoice]# power on
----

Now enter device discovery mode

[source, console]
----
(insert) [DustVoice]# scan on
----

and list found devices

[source, console]
----
(insert) [DustVoice]# devices
----

[NOTE]
====
You can turn device discovery mode off again, after your desired device has already be found

[source, console]
----
(insert) [DustVoice]# scan off
----
====

Now turn the agent on

[source, console]
----
(insert) [DustVoice]# agent on
----

and pair with your device

[source, console]
----
(insert) [DustVoice]# pair <MAC_address>
----

[NOTE]
====
If your device doesn't support PIN verification you might need to manually trust the device

[source, console]
----
(insert) [DustVoice]# trust <MAC_address>
----
====

Finally connect to your device

[source, console]
----
(insert) [DustVoice]# connect <MAC_address>
----

[NOTE]
====
If your device is an audio device, of some kind you might have to install `pulseaudio-bluetooth` and append 2 lines to `/etc/pulse/system.pa` as well as restart the `pulseaudio` daemon.

So first the install

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S pulseaudio-bluetooth
----

now append the following 2 lines

./etc/pulse/system.pa
[source, text]
----
load-module module-bluetooth-policy
load-module module-bluetooth-discover
----

and restart `pulseaudio`

[source, console]
----
[I] dustvoice@DustArch ~
$ pulseaudo --kill
[I] dustvoice@DustArch ~
$ pulseaudo --start
----

to `/etc/pulse/system.pa`.
====

If you want a GUI to do all of this, just install `blueman` and launch `blueman-manager`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S blueman
[I] dustvoice@DustArch ~
$ blueman-manager &
----

=== Graphical desktop environment

If you decide, that you want to use a graphical desktop environment, you have to install additional packages in order for that to work.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S xorg xorg-xinit xorg-drivers i3 i3status rofi ttf-hack xfce4-terminal alsa alsa-utils arandr
----

==== NVIDIA

If you also want to use NVIDIA functionality, for example for `davinci-resolve`, you would need to install their proprietary driver

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S nvidia nvidia-utils nvidia-settings opencl-nvidia
----

[NOTE]
====
You would have to reboot sooner or later after installing the NVIDIA drivers.

Also to get the best performance, at least for something like screen capturing in `obs`, go to *X Server Display Configuration* inside `nvidia-settings`, switch to *Advanced* and enable *Force Composition Pipeline*, as well as *Force Full Composition Pipeline*.
====

==== Launching the grahpical environment

After that you can now do `startx` in order to launch the graphical environment.

If anything goes wrong in the process, remember that you can press *Ctrl+Alt+<Number>* to switch ``tty``s.

===== The NVIDIA way

If you're using an NVIDIA graphics card, you might want to use `nvidia-xrun` instead of `startx`.
This has the advantage, of the `nvidia` kernel modules not being loaded at boot (neither are the `nouveau` modules), thus saving power.
`nvidia-xrun` will then load the correct kernel modules and run the `.nvidia-xinitrc` script in your home directory (for more file locations look into the documentation for `nvidia-xrun`).

[IMPORTANT]
====
In most cases, `sudo` is required to run `nvidia-xrun`, as it needs to load kernel modules.
You can alternatively enable non-``sudo`` users to load kernel modules, although I haven't tested that variation.
====

Simply install `nvidia-xrun`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S nvidia bbswitch
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/nvidia-xrun.git
[I] dustvoice@DustArch ~
$ cd nvidia-xrun
[I] dustvoice@DustArch ~/nvidia-xrun
$ makepkg -si
[I] dustvoice@DustArch ~/nvidia-xrun
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf nvidia-xrun
----

[NOTE]
====
If your hardware doesn't support bbswitch, you would need to run

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S nvidia
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/nvidia-xrun-pm.git
[I] dustvoice@DustArch ~
$ cd nvidia-xrun-pm
[I] dustvoice@DustArch ~/nvidia-xrun-pm
$ makepkg -si
[I] dustvoice@DustArch ~/nvidia-xrun-pm
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf nvidia-xrun-pm
----

instead.
====

Now we need to blacklist *both `nouveau` and `nvidia`* kernel modules.

To do that, we first have to find out, where our active `modprobe.d` directory is located.
There are 2 possible locations, generally speaking: `/etc/modprobe.d` or `/usr/lib/modprobe.d`.
In my case it was the latter, which I could tell, because this directory already had files in it.
You might have to try it out tho.

Now I'll create a new file named `nvidia-xrun.conf` and write the following into it

./usr/lib/modprobe.d/nvidia-xrun.conf
[source, text, linenums]
----
blacklist nvidia
blacklist nvidia-drm
blacklist nvidia-modeset
blacklist nvidia-uvm
blacklist nouveau
----

With this config in place

[source, console]
----
[I] dustvoice@DustArch ~
$ lsmod | grep nvidia
----

and

[source, console]
----
[I] dustvoice@DustArch ~
$ lsmod | grep nouveau
----

should return no output.
Else you might have to place some additional entries into the file.

[NOTE]
====
If you installed `nvidia-xrun-pm` instead of `nvidia-xrun` and `bbswitch`, you might want to also enable the `nvidia-xrun-pm` service

[source, console]
----
[I] dustvoice@dustArch ~
$ sudo systemctl enable nvidia-xrun-pm.service
----
====

[NOTE]
====
The required `.nvidia-xinitrc` file, mentioned previously, should already be provided in the `dotfiles` repository.
====

Now instead of `startx`, just run `nvidia-xrun`, enter your `sudo` password and you're good to go.

=== GUI Software

As you now have a working graphical desktop environment, you might want to install some software to utilize your newly gained power

==== Desktop background

You might want to consider installing `nitrogen`, in order to be able to set a background image

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S nitrogen
----

==== Compositing software

To get buttery smooth animation as well as e.g. video playback in `brave`, you might want to consider using a `compton` based software named `picom`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S picom
----

Now edit the file `~/.config/i3/config` and uncomment the `picom` line in order to start `picom` with `i3`.

[WARNING]
====
In order for ``obs``' screen capture to work correctly, you need to kill `picom` completely before using `obs`.

[source, console]
----
[I] dustvoice@DustArch ~
$ pkill picom
----

or

[source, console]
----
[I] dustvoice@DustArch ~
$ ps aux | grep picom
[I] dustvoice@DustArch ~
$ kill <pid>
----
====

==== `networkmanager` applet

To install the `NetworkManager` applet, which lives in your tray and provides you with a quick method to connect to different networks, you have to install the `network-manager-applet` package

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S network-manager-applet
----

Now you can start the applet with

[source, console]
----
[I] dustvoice@DustArch ~
$ nm-applet &
----

If you want to edit the network connections with a more fullscreen approach you can also launch `nm-connection-editor`.

[NOTE]
====
The `nm-connection-editor` doesn't search for available WiFis.
You would have to set up a WiFi connection completely by hand, which could be desireable depending on how difficult your WiFi is to set up.
====

==== Keyboard

To show, which keyboard layout and variant is currently in use, you can use `xkblayout-state`, which you can aquire from the `aur`

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/xkblayout-state.git
[I] dustvoice@DustArch ~
$ cd xkblayout-state
[I] dustvoice@DustArch ~/xkblayout-state
$ makepkg -si
[I] dustvoice@DustArch ~/xkblayout-state
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf xkblayout-state
----

Now simply issue the `layout` alias, provided by our custom `fish` configuration.

==== X clipboard

To copy something from the terminal to the x clipboard, use `xclip`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S xclip
[I] dustvoice@DustArch ~
$ xclip some_random_text
----

==== Taking screenshots

For this functionality, especially in combination with `rofi`, use `scrot`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S scrot
[I] dustvoice@DustArch ~
$ scrot filename.png
----

==== Image viewer

Now that we can create screenshots, we might also want to view those

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S ristretto
[I] dustvoice@DustArch ~
$ ristretto filename.png
----

==== File manager

You probably also want to use a file manager.
In my case, `thunar`, the `xfce` file manager, worked best.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S thunar
----

To also be able to mount removable drives, without root, and in order to have a GUI for mounting stuff, you would need to install `gigolo` and `gvfs`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S gigolo gvfs
----

===== Android file transfer

To furthermore enable the transfer of files between your pc and your android phone, you'll habe to install the `mtp` libraries

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S libmtp gvfs-mtp
----

Now you should be able to see your phone inside either `thunar`, or `gigolo`.

If you want to access the android's filesystem from the command line, you will need to either install `simple-mtpfs`

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/simple-mtpfs.git
[I] dustvoice@DustArch ~
$ cd simple-mtpfs
[I] dustvoice@DustArch ~/simple-mtpfs
$ makepkg -si
[I] dustvoice@DustArch ~/simple-mtpfs
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf simple-mtpfs
----

edit `/etc/fuse.conf` to uncomment

./etc/fuse.conf
[source, text]
----
user_allow_other
----

and mount the android device

[source, console]
----
[I] dustvoice@DustArch ~
$ simple-mtpfs -l
[I] dustvoice@DustArch ~
$ mkdir ~/mnt
[I] dustvoice@DustArch ~
$ simple-mtpfs --device <number> ~/mnt -allow_other
----

and respectively unmount it

[source, console]
----
[I] dustvoice@DustArch ~
$ fusermount -u mnt
[I] dustvoice@DustArch ~
$ rmdir mnt
----

or you need to install `adb`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S adb
----

And kill the `adb` server (if it is running)

[source, console]
----
[I] dustvoice@DustArch ~
$ adb kill-server
----

[NOTE]
====
If the server is currently not running, `adb` will output an error with a `Connection refused` message.
====

Now connect your phone and unlock it and start the `adb` server

[source, console]
----
[I] dustvoice@DustArch ~
$ adb start-server
----

If the pc is unknown to the android device, it will display a confirmation dialog.
Accept it and ensure that the device was recognized

[source, console]
----
[I] dustvoice@DustArch ~
$ adb devices
----

Now you can ``push``/``pull`` files.

[source, console]
----
[I] dustvoice@DustArch ~
$ adb pull /storage/emulated/0/DCIM/Camera/IMG.jpg .
[I] dustvoice@DustArch ~
$ adb push IMG.jpg /storage/emulated/0/DCIM/Camera/IMG2.jpg
[I] dustvoice@DustArch ~
$ adb kill-server
----

[NOTE]
====
Of course you would need to have the _developer options_ unlocked as well as the _USB debugging_ option enabled within them for `adb` to even work.
====

==== Archive manager

As we now have a file manager, it might be annoying, to open up a terminal everytime you simply want to extract an archive of some sort.

That's why we'll install `xarchiver`.

In order for `xarchiver` to work its full potential we're first gonna install some additional archive types

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S p7zip zip unrar cpio
----

Now we can proceed to install `xarchiver`

[source, console]
----
[I] dustvoice@DustArch ~
$ xarchiver
----

==== Partition management

You may also choose to use a graphical partitioning software instead of `fdisk` or `cfdisk`.
For that you can install `gparted`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S gparted
----

==== PDF viewer

As we've installed `asciidoctor-pdf` previously, you might be wondering how you are supposed to open the generated pdfs.
There are two ways.

===== Using the GUI

Installing `mupdf` is as simple as issuing

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S mupdf
----

If you want to have changes made to the pdf reflected immediately in the viewer, you would need `evince` instead

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S evince
----

===== Using the framebuffer

If you want to not always use the graphical desktop with `mupdf`, you might be interested in the `fbgs` software.

This software renders a pdf document using the native framebuffer.
To install it simply do

[source, console]
----
[I] dustvoice@DustArch ~
$ pacman -S fbida ghostscript
----

and to view this pdf document (`Documentation.pdf`) for example, you would run

[source, console]
----
[I] dustvoice@DustArch ~
$ fbgs Documentation.pdf
----

[INFO]
====
You can view all the controls by pressing `h`.
====

==== Web browser

As you're already using a GUI, you also might be interested in a web browser.
In my case, I'll install `brave` from the AUR as well as `browserpass` from the official repositories for using my passwords in `brave`.

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/brave-bin.git
[I] dustvoice@DustArch ~/brave-bin
$ makepkg -si
[I] dustvoice@DustArch ~/brave-bin
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf brave-bin
[I] dustvoice@DustArch ~
$ sudo pacman -S browserpass
----

Now we still have to setup `browserpass`

[source, console]
----
[I] dustvoice@DustArch ~
$ cd /usr/local/lib/browserpass
[I] dustvoice@DustArch /usr/local/lib/browserpass
$ make hosts-brave-user
[I] dustvoice@DustArch /usr/local/lib/browserpass
$ make policies-brave-user
[I] dustvoice@DustArch /usr/local/lib/browserpass
$ cd ~
----

Now the only thing left is, to fire up `brave` and install the `browserpass` extension from the chrome store.

===== Entering the dark side

You might have to be completely anonymous whilst browsing the web at some point.
Although this shouldn't be your only precaution, using `tor-browser` would be the first thing to use

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/tor-browser.git
[I] dustvoice@DustArch ~
$ cd tor-browser
[I] dustvoice@DustArch ~/tor-browser
$ makepkg -si
[I] dustvoice@DustArch ~/tor-browser
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf tor-browser
----

==== Office utilities

For now we'll install `libreoffice-fresh`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S libreoffice-fresh
----

===== Printing

In order for printing to work with my printer, which is a _Brother MFC J497DW_, I had do install `avahi`, `cups`, `cups-pdf`, `nss-mdns` and the correspoding driver for my printer.
In order to be able to print from the `gtk` print dialogue, we'll also need to install `system-config-printer` and `print-manager`.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S avahi
[I] dustvoice@DustArch ~
$ sudo pacman -S cups cups-pdf nss-mdns
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/brother-mfc-j497dw.git
[I] dustvoice@DustArch ~
$ cd brother-mfc-j497dw
[I] dustvoice@DustArch ~/brother-mfc-j497dw
$ makepkg -si
[I] dustvoice@DustArch ~/brother-mfc-j497dw
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf brother-mfc-j497dw
[I] dustvoice@DustArch ~
$ sudo systemctl enable avahi-daemon.service
[I] dustvoice@DustArch ~
$ sudo systemctl start avahi-daemon.service
----

Now you have to edit `/etc/nsswitch.conf`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo nvim /etc/nsswitch.conf
----

so this line

[source, text]
----
hosts: files mymachines myhostname resolve [!UNAVAIL=return] dns
----

becomes this line

[source, text]
----
hosts: files mymachines myhostname mdns4_minimal [NOTFOUND=return] resolve [!UNAVAIL=return] dns
----

Now continue with this

[source, text]
----
[I] dustvoice@DustArch ~
$ avahi-browse --all --ignore-local --resolve --terminate
[I] dustvoice@DustArch ~
$ sudo systemctl enable org.cups.cupsd.service
[I] dustvoice@DustArch ~
$ sudo systemctl start org.cups.cupsd.service
[I] dustvoice@DustArch ~
$ sudo pacman -S system-config-printer print-manager
----

Now just open up `system-config-printer` and configure your printer.

To test if everything is working, you could open up `brave`, the go to *Print* and then try printing.

==== Process management

The native linux tool to have a CLI task-manager, is `top`.

The next evolutionary step would be `htop`, which is a improved version of `top` (like `vi` and `vim` for example)

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S htop
----

If you prefer a GUI for that kind of task, install `xfce4-taskmanager`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S xfce4-taskmanager
----

==== Communication

Life is all about communicating.
Here are some pieces of software to do exactly that.

===== Email

There is nothing better than some classical email.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S thunderbird
----

===== Telegram

You want to have your `telegram` messages on your desktop pc?

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S telegram-desktop
----

===== TeamSpeak 3

Wanna chat with your gaming friends and they have a `teamspeak3` server? Go for it

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S teamspeak3
----

===== Discord

You'd rather use `discord`? No problem

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S discord
----

==== Video software

Just some additional software related to videos.

===== Viewing video

You might consider using `vlc`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S vlc
----

===== Creating video

`obs` should be the right choice

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/obs-studio-git
[I] dustvoice@DustArch ~
$ cd obs-studio-git
[I] dustvoice@DustArch ~/obs-studio-git
$ makepkg -si
[I] dustvoice@DustArch ~/obs-studio-git
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf obs-studio-git
----

====== Showing keystrokes

In order to show the viewers what keystrokes you're pressing, you can use something like `screenkey`

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/screenkey.git
[I] dustvoice@DustArch ~
$ cd screenkey
[I] dustvoice@DustArch ~/screenkey
$ makepkg -si
[I] dustvoice@DustArch ~/screenkey
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf screenkey
[I] dustvoice@DustArch ~
$ screenkey
----

[NOTE]
====
For ideal use with `obs`, my `dotfiles` repository already provides you with the `screenkey-obs` script for you to run with `fish`.
====

===== Live stream a terminal session

For this task, you'll need a program called `tmate`.
Just install it

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S tmate
----

and run it

[source, console]
----
[I] dustvoice@DustArch ~
$ tmate
----

===== Editing video

In my case, I'm using `davinci-resolve`.

But before installing `davinci-resolve`, we have to enable 32-bit packages.
Just edit `/etc/pacman.conf` and uncomment the `multilib` lines.

Then update your packages

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -Sy
----

and install `davinci-resolve`

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/davinci-resolve.git
[I] dustvoice@DustArch ~
$ cd davinci-resolve
[I] dustvoice@DustArch ~/davinci-resolve
$ makepkg -si
[I] dustvoice@DustArch ~/davinci-resolve
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf davinci-resolve
----

===== Utilizing video

Wanna remote control your/another pc? `teamviewer` might just be the right choice for you

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/teamviewer.git
[I] dustvoice@DustArch ~
$ cd teamviewer
[I] dustvoice@DustArch ~/teamviewer
$ makepkg -si
[I] dustvoice@DustArch ~/teamviewer
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf teamviewer
----

==== Ardour

To e.g. edit and produce audio, I would recommend `ardour`, because it's easy to use, stable and cross platform.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S ardour
----

[NOTE]
====
You might have to edit `/etc/security/limits.conf`, to increase the allowed locked memory amount.

In my case I have 32GB of RAM and I want the `audio` group to be allocate most of the RAM, which is why I added the following line to the file

[source, text]
----
@audio - memlock 29360128
----
====

[INFO]
====
Ardour won't natively save in the `mp3` format due to licensing stuff.
In order to create `mp3` files, for sharing with other devices that have problems with `wav` files for example, you can just use `ffmpeg`.

First make sure it's installed

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S ffmpeg
----

and after that we're going to convert `in.wav` to `out.mp3`

[source, console]
----
[I] dustvoice@DustArch ~
$ ffmpeg -i in.wav -acodec mp3 out.mp3
----
====

==== Virtualization

You might need to run another os, for example Mac OS, from within Linux, e.g. for development/testing purposes.
For that you can use `virtualbox`

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S virtualbox virtualbox-host-modules-arch
----

Now when you want to use `virtualbox` just load the kernel module

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo modprobe vboxdrv
----

and add the user which is supposed to run `virtualbox` to the `vboxusers` group

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo usermod -a G vboxusers $USER
----

and if you want to use `rawdisk` functionality, also to the `disk` group

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo usermod -a G disk $USER
----

Now just re-login and you're good to go.

// Longterm TODO: After getting a system with 2 GPUs, add part for KVMing a Windows.
// Resources:
// - virt-manager
// - wiki.archlinux.org/index.php/KVM
// - wiki.debian.org/VGAPassthrough
// - ycnrg.org/vga-passthrough-with-ovmf-vfio
// - bufferoverflow.io/gpu-passthrough
// - heiko-sieger.info/running-windows-10-on-linux-using-kvm-with-vga-passthrough
// - openwebit.com/c/how-to-run-windows-vm-on-more-than-2-cores-under-kvm

==== Gaming

The first option for native/emulated gaming on linux is obviously `steam`.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S steam lib32-nvidia-utils pulseaudio pulseaudio-alsa lib32-libpulse
----

The second option would be `lutris`, a program, that configures a wine instance correctly, etc.

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S lutris
----

==== Wacom

In order to use a wacom graphics tablet, you'll have to install some packages

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -S libwacom xf86-input-wacom
----

You could now configure your tablet using the `xsetwacom` command.
But on the other hand there is also `wacom-utility`, a GUI software for all of that, so you could try if that works first.

[source, console]
----
[I] dustvoice@DustArch ~
$ git clone https://aur.archlinux.org/wacom-utility.git
[I] dustvoice@DustArch ~
$ cd wacom-utility
[I] dustvoice@DustArch ~/wacom-utility
$ git clone https://aur.archlinux.org/gksu.git
[I] dustvoice@DustArch ~/wacom-utility
$ cd gksu
[I] dustvoice@DustArch ~/wacom-utility/gksu
$ git clone https://aur.archlinux.org/libgks.git
[I] dustvoice@DustArch ~/wacom-utility/gksu
$ cd libgks
[I] dustvoice@DustArch ~/wacom-utility/gksu/libgks
$ makepkg -si
[I] dustvoice@DustArch ~/wacom-utility/gksu/libgks
$ cd ..
[I] dustvoice@DustArch ~/wacom-utility/gksu
$ makepkg -si
[I] dustvoice@DustArch ~/wacom-utility/gksu
$ cd ..
[I] dustvoice@DustArch ~/wacom-utility
$ makepkg -si
[I] dustvoice@DustArch ~/wacom-utility
$ cd ..
[I] dustvoice@DustArch ~
$ rm -rf wacom-utility
----

== Upgrading the system

You're probably wondering why this gets a dedicated section.
You'll probably think that it would be just a matter of issuing

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -Syu
----

That's both true and false.
You have to make sure, *that your boot partition is mounted at `/boot`* in order for everything to upgrade correctly.
That's because the moment you upgrade the `linux` package without having the correct partition mounted at `/boot`, your system won't boot.

If your system *indeed doesn't boot* and *boots to a recovery console*, then double check that the issue really is the not perfectly executed kernel update by issuing

[source, console]
----
[I] root@DustArch ~
$ uname -a
----

and

[source, console]
----
[I] root@DustArch ~
$ pacman -Q linux
----

*The version of these two packages should be exactly the same!*

If it isn't there is an easy fix for it

=== Fixing a faulty kernel upgrade

First off we need to restore the old `linux` package.

For that note the version number of

[source, console]
----
[I] root@DustArch ~
$ uname -a
----

Now we'll make sure first that nothing is mounted at `/boot`, because the process will likely create some unwanted files.
The process will also create a new `/boot` folder, which we're going to delete afterwards.

[source, console]
----
[I] root@DustArch ~
$ umount /boot
----

Now `cd` into ``pacman``'s package cache

[source, console]
----
[I] root@DustArch ~
$ cd /var/cache/pacman/pkg
----

There should be a file located named something like `linux-<version>.pkg.tar.xz`, where `<version>` would be somewhat equivalent to the previously noted version number

Now downgrade the `linux` package

[source, console]
----
[I] root@DustArch ~
$ pacman -U linux-<version>.pkg.tar.xz
----

After that remove the possibly created `/boot` directory

[source, console]
----
[I] root@DustArch ~
$ rm -rf /boot
[I] root@DustArch ~
$ mkdir /boot
----

Now reboot and mount the `boot` partition, in my case an `EFI System Partition`.

Now simply rerun

[source, console]
----
[I] dustvoice@DustArch ~
$ sudo pacman -Syu
----

and you should be fine now.

[NOTE]
====
Consider setting up a `fstab` entry for the boot partition, in order to avoid such dilemma in the future.

See <<setting-up-fstab>> for more.
====

== `DustArch` package list

A complete list of all the packages present on my full fledged system at the time of writing

.packages-x86_64
[source, text, linenums]
----
include::.packages-x86_64[]
----
