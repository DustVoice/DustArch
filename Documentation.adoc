= DustArch: DustVoice's Arch Linux from scratch
David Holland <info@dustvoice.de>
v6.0, 2020-01-24
:doctype: book
:docinfo: shared
:title-logo-image: image:arch.png[]
:toc: left
:toc-title: Table Of Contents
:toclevels: 4
:sectnums:
:sectnumlevels: 4
:chapter-label:
:pagenums!:
:source-highlighter: pygments
:icons: font
:last-update-label: Last modified:
:table-caption!:

== Inside the `archiso`

This section is aimed at providing help with the general installation of a customized Arch Linux from within an official Arch Linux image (`archiso`).

[NOTE]
====
As Arch Linux is a rolling release Linux distribution, it is advised, to have a working internet connection, in order to get the latest package upgrades and to install additional software, as the `archiso` only has very few packages available from cache.

Furthermore, one should bear in mind that depending on the version, or rather modification date, the guide may already be outdated.
If you encounter any problems along the way, you will either have to resolve the issue yourself, or utilize the great https://wiki.archlinux.org/[ArchWiki], or the https://bbs.archlinux.org/[Arch Linux forums].
====

<<<

=== ``Sy``nc up `pacman`

First of all we need to sync up ``pacman``'s package repository, in order to be able to install packages

[source, console]
----
root@archiso ~ # pacman -Sy
----

After doing that, we can now install any software from the official repositories by issuing

[source, console]
----
root@archiso ~ # pacman -S <package_name>
----

where you would replace `<package_name>` with the actual package name.

If you don't know the exact package name, or if you just want to search for a keyword, for example `xfce` to list all packages having to do something with `xfce`, use

[source, console]
----
root@archiso ~ # pacman -Ss <keyword>
----

If you want to remove an installed package, just use

[source, console]
----
root@archiso ~ # pacman -Rsu <package_name>
----

[CAUTION]
====
If you have to force remove, which you should use *with extreme caution*, you can use

[source, console]
----
root@archiso ~ # pacman -Rdd <package_name>
----
====

If you want to install a package from the https://aur.archlinux.org/[`AUR`], I would proceed as follows

. `cd` into the dedicated directory, if you're using the `dotfiles` repo, which provides an `update.sh` script within that folder, to check every subfolder for updates
+
[source, console]
----
dustvoice@archiso ~ $ cd AUR
----

. Clone the package with `git`
+
[source, console]
----
dustvoice@archiso ~/AUR $ git clone https://aur.archlinux.org/pacman-git.git
----

. Switch to the package directory
+
[source, console]
----
dustvoice@archiso ~/AUR $ cd pacman-git
----

. Execute `makepkg`
+
[source, console]
----
dustvoice@archiso ~/AUR/pacman-git $ makepkg -si
----

. Delete all files created by `makepkg`, in order to easily see, if a package needs an update by using `git fetch --all` and `git status`
+
[source, console]
----
dustvoice@archiso ~/AUR/pacman-git $ git reset HEAD --hard
dustvoice@archiso ~/AUR/pacman-git $ git clean -fdx
----

[NOTE]
====
You might have to resolve any `AUR` dependencies, which can't be resolved with `pacman`.
====

[WARNING]
====
In order to install that `AUR` package, you *must* switch to your normal user, because `makepkg` doesn't run as root.
====


<<<

=== Formatting the drive

First you have to list all the available drives by issuing

[source, console]
----
root@archiso ~ # fdisk -l
----

[NOTE]
====
The output of `fdisk -l` is dependent on your system configuration.
====

In my case, the partition I want to install the root file system on is `/dev/sdb2`.
`/dev/sdb3` will be my `swap` partition.

[NOTE]
====
A `swap` size *twice the size of your RAM* is recommended by a lot of people.

With bigger RAM sizes available today, this isn't necessary anymore.
To be exact, every distribution has different recommendations for `swap` sizes.

Also `swap` size heavily depends on whether you want to be able to hibernate, etc.

You should make the `swap` size *at least your RAM size* and for RAM sizes over `4GB` and the wish to hibernate, at least one and a half your RAM size.
====

[IMPORTANT]
====
If you haven't yet partitioned your disk, please refer to the link:https://wiki.archlinux.org/index.php/Partitioning[general partitioning tutorial] in the ArchWiki.
====

Now we need to format the partitions accordingly

[source, console]
----
root@archiso ~ # mkfs.ext4 /dev/sdb2
root@archiso ~ # mkswap /dev/sdb3
----

After doing that, we can turn on the `swap` and `mount` the root partition.

[source, console]
----
root@archiso ~ # swapon /dev/sdb3
root@archiso ~ # mount /dev/sdb2 /mnt
----

[NOTE]
====
If you have an additional `EFI system partition`, because of a _UEFI - GPT_ setup or e.g. an existing Windows installation, which we will assume to be located under `/dev/sda2` (`/dev/sda` is the disk of my Windows install), you'll have to `mount` this partition to the new systems `/boot` folder

[source, console]
----
root@archiso ~ # mkdir /mnt/boot
root@archiso ~ # mount /dev/sda2 /mnt/boot
----
====

<<<

=== Preparing the `chroot` environment

First it might make sense to edit `/etc/pacman.d/mirrorlist` to move the mirror(s) geographically closest to you to the top.

After that we can either install the *bare minimum packages* needed

[source, console]
----
root@archiso ~ # pacstrap /mnt base linux linux-firmware
----

or install *all packages present* on the archiso, which makes sense in our case

[source, console]
----
root@archiso ~ # pacstrap /mnt base base-devel linux linux-firmware $(pacman -Qq | tr '\n' ' ')
----

_This could take quite some time depending on your Internet connection speed._

After that generate an `fstab` using `genfstab`

[source, console]
----
root@archiso ~ # genfstab -U /mnt >> /mnt/etc/fstab
----

and you're ready to enter the `chroot` environment.

<<<

== Entering the `chroot`

[NOTE]
====
As we want to set up our new system, we need to have access to the different partitions, the internet, etc. which we wouldn't get by solely using `chroot`.

That's why we are using `arch-chroot`, provided by the `arch-install-scripts` package already shipped with the archiso.
This script takes care of all that stuff, so we can set up our system properly.
====

[source, console]
----
root@archiso ~ # arch-chroot /mnt
----

Et Voila! You successfully ``chroot``ed inside your new system and you'll be greeted by a `bash` prompt.

<<<

=== Installing additional packages

First off you'll probably need a text editor.

There are many command line text editors available, like `nano`, `vi`, `vim`, `emacs`, etc.

I'll be using `neovim`, though it shouldn't matter what editor you choose.

[source, console]
----
[root@archiso /]# pacman -S neovim
----

After that we'll make sure we get ourselves some basic utilities and enable the `NetworkManager.service` service, in order for the Internet connection to work upon booting into our fresh system later on.

[source, console]
----
[root@archiso /]# pacman -S sudo iputils dhcpcd dhclient grub dosfstools os-prober mtools networkmanager networkmanager-openvpn networkmanager-openconnect
[root@archiso /]# systemctl enable NetworkManager.service
----

Furthermore you'll also need to make sure `polkit` is installed

[source, console]
----
[root@archiso /]# pacman -S polkit
----

and then create a file `/etc/polkit-1/rules.de/50-org.freedesktop.NetworkManager.rules` to enable users of the `network` group to add new networks without the need of `sudo`.

./etc/polkit-1/rules.de/50-org.freedesktop.NetworkManager.rules
[source, text]
----
polkit.addRule(function(action, subject) {
    if (action.id.indexOf("org.freedesktop.NetworkManager.") == 0 && subject.isInGroup("network")) {
        return polkit.Result.YES;
    }
});
----

If you use `UEFI`, you'll also need

[source, console]
----
[root@archiso /]# pacman -S efibootmgr
----

<<<

=== Master of time

After that you have to set your timezone and update the system clock.

Generally speaking, you can find all the different timezones under `/usr/share/zoneinfo`.
In my case, my timezone resides under `/usr/share/zoneinfo/Europe/Berlin`.

To achieve the desired result, I want to symlink this to `/etc/localtime` and set the hardware clock.

[source, console]
----
[root@archiso /]# ln -s /usr/share/zoneinfo/Europe/Berlin /etc/localtime
[root@archiso /]# hwclock --systohc --utc
----

Now you can also enable time synchronization over network

[source, console]
----
[root@archiso /]# timedatectl set-timezone Europe/Berlin
[root@archiso /]# timedatectl set-ntp true
[root@archiso /]# timedatectl status
----

and check that everything is alright

[source, console]
----
[root@archiso /]# timedatectl status
----

<<<

=== Master of locales

Now you have to generate your locale information.

For that you have to edit `/etc/locale.gen` and uncomment the locales you want to enable.

[NOTE]
====
I recommend to always uncomment `en_US.UTF-8 UTF8`, even if you want to use another language primarily.
====

In my case I only uncommented the `en_US.UTF-8 UTF8` line

./etc/locale.gen
[source, text]
----
en_US.UTF-8 UTF8
----

After that you still have to actually generate the locales by issuing

[source, console]
----
[root@archiso /]# locale-gen
----

and set the locale

[source, console]
----
[root@archiso /]# localectl set-locale LANG="en_US.UTF-8"
----

After that we're done with this part.

<<<

=== Naming your machine

Now we can set the `hostname` and add `hosts` entries.

Apart from being mentioned in your command prompt, the `hostname` also serves the purpose of identifying, or naming your machine.
This enables you to see your PC in your router, etc.

<<<

==== `hostname`

To change the `hostname`, simply edit `/etc/hostname`, enter the desired name, then save and quit.

./etc/hostname
[source, text]
----
DustArch
----

<<<

==== `hosts`

Now we need to specify some `hosts` entries by editing `/etc/hosts`

./etc/hosts
[source, text]
----
# Static table lookup for hostnames.
# See hosts(5) for details.

127.0.0.1   localhost           .
::1         localhost           .
127.0.1.1   DustArch.localhost  DustArch
----

<<<

=== User setup

Now you should probably change the default `root` password and create a new non-``root`` user for yourself, as using your new system purely through the native `root` user is not recommended from a security standpoint.

<<<

==== Give `root` a password

To change the password for the current user (the `root` user) issue

[source, console]
----
[root@archiso /]# passwd
----

and choose a new password.

<<<

[#create-a-personal-user]
==== Create a personal user

We are going to make sure the `zsh` shell is installed, create a new user, set the password for this user, make sure the `sudo` package is installed and allow the `wheel` group `sudo` access.

[source, console]
----
[root@archiso /]# pacman -S zsh
[root@archiso /]# useradd -m -p "" -G "adm,audio,disk,floppy,kvm,log,lp,network,rfkill,scanner,storage,users,optical,power,wheel" -s /usr/bin/zsh dustvoice
[root@archiso /]# passwd dustvoice
[root@archiso /]# pacman -S sudo
----

We now have to allow the `wheel` group `sudo` access.

For that we edit `/etc/sudoers` and uncomment the `%wheel` line

./etc/sudoers
[source, text]
----
%wheel ALL=(ALL) ALL
----

You could also add a new line below the `root` line

./etc/sudoers
[source, text]
----
root ALL=(ALL) ALL
----

with your new username

./etc/sudoers
[source, text]
----
dustvoice ALL=(ALL) ALL
----

to solely grant yourself `sudo` privileges.

<<<

=== Preparing to boot

Now onto installing the boot manager.
We will use `grub` in this guide.

First make sure, all the required packages are installed

[source, console]
----
[root@archiso /]# pacman -S grub dosfstools os-prober mtools
----

and if you want to use `UEFI`, also

[source, console]
----
[root@archiso /]# pacman -S efibootmgr
----

<<<

==== `BIOS`

If you chose the `BIOS - MBR` variation, you'll have to *do nothing special*

If you chose the `BIOS - GPT` variation, you'll have to *have a `+1M` boot partition* created with the partition type set to `BIOS boot`.

In both cases you'll have to *run the following comman* now

[source, console]
----
[root@archiso /]# grub-install --target=i386-pc /dev/sdb
----

[NOTE]
====
It should obvious that you would need to replace `/dev/sdb` with the disk you actually want to use.
Note however that you have to specify a *disk* and *not a partition*, so *no number*.
====

<<<

==== `UEFI`

If you chose the `UEFI - GPT` variation, you'll have to *have the `EFI System Partition` mounted* at `/boot` (where `/dev/sda2` is the partition holding said `EFI System Partition` in my particular setup)

Now *install `grub` to the `EFI System Partition`*

[source, console]
----
[root@archiso /]# grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub --recheck
----

[IMPORTANT]
====
If you've planned on dual booting arch with Windows and therefore reused the `EFI System Partition` created by Windows, you might not be able to boot to grub just yet.

In this case, boot into Windows, open a `cmd` window as Administrator and type in

[source, console]
----
bcdedit /set {bootmgr} path \EFI\grub\grubx64.efi
----

To make sure that the path is correct, you can use

[source, console]
----
[root@archiso /]# ls /boot/EFI/grub
----

under Linux to make sure, that the `grubx64.efi` file is really there.
====

<<<

==== `grub` config

In all cases, you now have to create the main `grub.cfg` configuration file.

But before we actually generate it, we'll make some changes to the default `grub` settings, which the `grub.cfg` will be generated from.

<<<

===== Adjust the timeout

First of all, I want my `grub` menu to wait indefinitely for my command to boot an OS.

./etc/default/grub
[source, text]
----
GRUB_TIMEOUT=-1
----

[NOTE]
====
I decided on this, because I'm dual booting with Windows and after Windows updates itself, I don't want to accidentally boot into my Arch Linux, just because I wasn't quick enough to select the Windows Boot Loader from the `grub` menu.

Of course you can set this parameter to whatever you want.

Another way of achieving what I described, would be to make `grub` remember the last selection.

./etc/default/grub
[source, text]
----
GRUB_TIMEOUT=5
GRUB_DEFAULT=saved
GRUB_SAVEDEFAULT="true"
----
====

<<<

===== Enable the recovery

After that I also want the recovery option showing up, which means that besides the standard and fallback images, also the recovery one would show up.

./etc/default/grub
[source, text]
----
GRUB_DISABLE_RECOVERY=false
----

<<<

===== NVIDIA fix

Now, as I'm using the binary NVIDIA driver for my graphics card, I also want to make sure, to revert `grub` back to text mode, after I select a boot entry, in order for the NVIDIA driver to work properly.
You might not need this

./etc/default/grub
[source, text]
----
GRUB_GFXPAYLOAD_LINUX=text
----

<<<

===== Add power options

I also want to add two new menu entries, to enable me to shut down the PC, or reboot it, right from the `grub` menu.

./etc/grub.d/40-custom
[source, text]
----
menuentry '=> Shutdown' {
    halt
}

menuentry '=> Reboot' {
    reboot
}
----

<<<

===== Installing `memtest`

As I want all possible options to possibly troubleshoot my PC right there in my `grub` menu,  without the need to boot into a live OS, I also want to have a memory tester there.

====== `BIOS`

For a `BIOS` setup, you'll need `memtest86+`

[source, console]
----
[root@archiso /]# pacman -S memtest86+
----

====== `UEFI`

For a `UEFI` setup, you'll need `memtest86-efi` from the `AUR`.

[source, console]
----
[root@archiso /]# pacman -S base-devel
[root@archiso /]# sudo -iu dustvoice
[dustvoice@archiso ~]$ cd AUR
[dustvoice@archiso ~/AUR]$ git clone https://aur.archlinux.org/memtest86-efi
[dustvoice@archiso ~/AUR]$ cd memtest86-efi
[dustvoice@archiso ~/AUR/memtest86-efi]$ makepkg -si
[dustvoice@archiso ~/AUR/memtest86-efi]$ git reset HEAD --hard
[dustvoice@archiso ~/AUR/memtest86-efi]$ git clean -fdx
[dustvoice@archiso ~/AUR/memtest86-efi]$ exit
----

Now we still need to tell `memtest86-efi` how to install itself

[source, console]
----
[root@archiso /]# memtest86-efi -i
----

Now select option 3, to install it as a `grub2` menu item.

<<<

===== Enabling hibernation

In order to use the hibernation feature, you'll have to make sure that your `swap` partition/file is at least the size of your RAM.

After that we need to perform two tasks

. Add the `resume` hook to `/etc/mkinitcpio.conf`, before `fsck` and definetely after `block`
+
./etc/mkinitcpio.conf
[source, console]
----
HOOKS=(base udev autodetect modconf block filesystems keyboard resume fsck)
----
. Add the `resume` kernel parameter to `/etc/default/grub`, containing my `swap` partition `UUID`, in my case
+
./etc/default/grub
[source, console]
----
GRUB_CMDLINE_LINUX_DEFAULT="loglevel=3 quiet resume=UUID=097c6f11-f246-40eb-a702-ba83c92654f2"
----

After that we have to run

[source, console]
----
[root@archiso /]# mkinitcpio -p linux
----

[NOTE]
====
If you have to change anything, like the `swap` partition `UUID`, inside the `grub` configuration files, you'll always have to rerun `grub-mkconfig` as explained in <<generating-the-grub-config>>.
====

[#generating-the-grub-config]
===== Generating the `grub` config

Now we can finally generate our `grub.cfg`

[source, console]
----
[root@archiso /]# grub-mkconfig -o /boot/grub/grub.cfg
----

Now you're good to boot into your new system.

<<<

=== Secure Boot

I know I told you that you're now good to boot into your new system. That is only correct, if you're *not* using Secure Boot.

You can either proceed by disabling Secure Boot in your firmware settings, or by using `shim` as kind of a pre-bootloader, as well as signing your bootloader (`grub`) and your kernel.

If you decided on using Secure Boot, you will first have to install `shim-signed` from `AUR`.

[source, console]
----
[root@archiso /]# sudo -iu dustvoice
[dustvoice@archiso ~]$ cd AUR
[dustvoice@archiso ~/AUR]$ git clone https://aur.archlinux.org/shim-signed
[dustvoice@archiso ~/AUR]$ cd shim-signed
[dustvoice@archiso ~/AUR/shim-signed]$ makepkg -si
[dustvoice@archiso ~/AUR/shim-signed]$ git reset HEAD --hard
[dustvoice@archiso ~/AUR/shim-signed]$ git clean -fdx
[dustvoice@archiso ~/AUR/shim-signed]$ exit
----

Now we just need to copy `shimx64.efi`, as well as `mmx64.efi` to our `EFI System Partition`

[source, console]
----
[root@archiso /]# cp /usr/share/shim-signed/shimx64.efi /boot/EFI/grub/
[root@archiso /]# cp /usr/share/shim-signed/mmx64.efi /boot/EFI/grub/
----

[NOTE]
====
If you have to use `bcdedit` from within Windows, as explained previously, you need to adapt the command accordingly

[source, console]
----
bcdedit /set {bootmgr} path \EFI\grub\shimx64.efi
----
====

Now you will be greeted by `MokManager` everytime you update your bootloader or kernel.

Just choose `Enroll hash from disk` and enroll your bootloader (`grubx64.efi`) and kernel (`vmlinuz-linux`).

Reboot and your system should fire up just fine.

<<<

== Inside the `DustArch`

This section helps at setting up the customized system from within an installed system.

This section mainly provides aid with the basic set up tasks, like networking, dotfiles, etc.

[NOTE]
====
Not everything in this section is mandatory.

This section is rather a guideline, because it is easy to forget some steps needed, for example `jack` for audio production, that only become apparent, when they're needed.

It is furthermore the responsibility of the reader to decide which steps to skip and which need further research.
As I mentioned, this is only a guide and not the answer to everything.
====

<<<

=== Someone there?

First we have to check if the network interfaces are set up properly.

To view the network interfaces with all their properties, we can issue

[source, console]
----
DustArch% ip link
----

To make sure that you have a working _Internet_ connection, issue

[source, console]
----
DustArch% ping archlinux.org
----

Everything should run smoothly if you have a wired connection.

If there is no connection and you're indeed using a wired connection, try restarting the `NetworkManager` service

[source, console]
----
DustArch% sudo systemctl restart NetworkManager.service
----

and then try ``ping``ing again.

If you're trying to utilize a Wi-Fi connection, use `nmcli`, the ``NetworkManager``'s command line tool, or `nmtui`, the `NetworkManager` terminal user interface, to connect to a Wi-Fi network.

[NOTE]
====
I never got `nmtui` to behave like I wanted it to, in my particular case at least, which is the reason why I use `nmcli` or the GUI tools.
====

First make sure, the scanning of nearby Wi-Fi networks is enabled for your Wi-Fi device

[source, console]
----
DustArch% nmcli radio
----

and if not, enable it

[source, console]
----
DustArch% nmcli radio wifi on
----

Now make sure your Wi-Fi interface appears under

[source, console]
----
DustArch% nmcli device
----

Rescan for available networks

[source, console]
----
DustArch% nmcli device wifi rescan
----

and list all found networks

[source, console]
----
DustArch% nmcli device wifi list
----

After that connect to the network

[source, console]
----
DustArch% nmcli device wifi connect --ask
----

Now try ``ping``ing again.

<<<

=== Update and upgrade

After making sure that you have a working Internet connection, you can then proceed to update and upgrade all installed packages by issuing

[source, console]
----
DustArch% sudo pacman -Syu
----

<<<

=== Enabling the `multilib` repository

In order to make 32-bit packages available to `pacman`, we'll need to enable the `multilib` repository in `/etc/pacman.conf` first.
Simply uncomment

./etc/pacman.conf
[source, text]
----
[multilib]
Include = /etc/pacman.d/mirrorlist
----

and update ``pacman``'s package repositories afterwards

[source, console]
----
DustArch% sudo pacman -Sy
----

<<<

=== Setting the correct shell

Of course you can use any shell you want.
In my case I'll be using the `zsh` shell.

[NOTE]
====
I am using `zsh` because of its auto completion functionality and extensibility, as well as a brilliant `vim` like navigation implementation through a plugin, though that might not be what you're looking for.
====

We already set the correct shell for the `dustvoice` user in the <<create-a-personal-user>> step, but I want to use `zsh` for the `root` user too, so I'll have to change ``root``'s default shell to it.

[source, console]
----
DustArch% sudo chsh -s /usr/bin/zsh root
----

Don't worry about the looks by the way, we're gonna change all that in just a second.

<<<

=== Version control

Next you'll probably want to install `git`.
Just do

[source, console]
----
DustArch% sudo pacman -S git
----

and you're good to go.
We'll care about the `.gitconfig` in just a second.

<<<

=== Security is important

If you've followed the tutorial using a recent version of the archiso, you'll probably already have the most recent version of `gnupg` installed by default.
Just to make sure, issue

[source, console]
----
DustArch% sudo pacman -S gnupg
----

<<<

==== Smartcard shenanigans

After that you'll still have to setup `gnupg` correctly.
In my case I have my private keys stored on a smartcard.

To use it, I'll have to install some packages first

[source, console]
----
DustArch% sudo pacman -S pcsclite libusb-compat ccid opensc
----

and then enable and start the `pcscd` service

[source, console]
----
DustArch% sudo systemctl enable pcscd.service
DustArch% sudo systemctl start pcscd.service
----

After that, you should be able to see your smartcard being detected

[source, console]
----
DustArch% gpg --card-status
----

[NOTE]
====
If your smartcard still isn't detected, try logging off completely or even restarting, as that sometimes is the solution to the problem.
====

<<<

[#additional-tools-setup-home]
=== Additional required tools

To minimize the effort required by the following steps, we'll install most of the required packages beforehand

[source, console]
----
DustArch% sudo pacman -S make cmake clang jdk-openjdk python python-pip pass openssh
----

This will ensure, we proceed through the following section without the need for interruption, because a package needs to be installed, so the following content can be condensed to the relevant informations.

<<<

[#setup-home]
=== Setting up a `home` environment

In this step we're going to setup a home environment for both the `root` and my personal `dustvoice` user.

[NOTE]
====
In my case these 2 home environments are mostly equivalent, which is why I'll execute the following commands as the `dustvoice` user first and then switch to the `root` user and repeat the same commands.

I decided on this, as I want to edit files with elevated permissions and still have the same editor style and functions/plugins.

Note that this comes with some drawbacks.
For example, if I change a configuration for my `dustvoice` user, I would have to regularly update it for the `root` user too.
This bears the problem, that I have to register my smartcard for the root user.
This in turn is problematic, cause the `gpg-agent` used for `ssh` authentication, doesn't behave well when used within a `su` or `sudo -i` session.
So in order to update ``root``'s config files I would either need to symlink everything, which I won't do, or I'll need to login as the `root` user now and then, to update everything.
====

[NOTE]
====
In my case, I want to access all my `git` repositories with my `gpg` key on my smartcard.
For that I have to configure the `gpg-agent` with some configuration files that reside in a `git` repository.
This means I will have to reside to using the `https` URL of the repository first and later changing the URL either in the corresponding `.git/config` file, or by issuing the appropriate command.
====

<<<

==== Use `dotfiles` for a base config

To provide myself with a base configuration, which I can then extend, I have created a `dotfiles` repository, which contains all kinds of configurations.

The special thing about this `dotfiles` repository is that it *is* my home folder.
By using a curated `.gitignore` file, I'm able to only include the configuration files I want to keep between installs into the repository and ignore everything else.

To achieve this very specific setup, I have to turn my home directory into said `dotfiles` repository first

[source, console]
----
DustArch% git init
DustArch% git remote add origin https://github.com/DustVoice/dotfiles.git
DustArch% git fetch
DustArch% git reset origin/master --hard
DustArch% git branch --set-upstream-to=origin/master master
----

Now I can issue any `git` command in my `~` directory, because it now is a `git` repository.

<<<

==== Set up `gpg`

As I wanted to keep my `dotfiles` repository as modular as possible, I utilize ``git``'s `submodule` feature.
Furthermore I want to use my `nvim` repository, which contains all my configurations and plugins for `neovim`, on Windows, but without all the Linux specific configuration files.
I am also using the `Pass` repository on my Android phone and Windows PC, where I only need this repository without the other Linux configuration files.

Before we'll be able to update the ``submodule``s (`nvim` config files and ``pass``word-store) though, we will have to setup our `gpg` key as an `ssh` key, as I use it to authenticate

[source, console]
----
dustvoice@DustArch ~
$ chmod 700 .gnupg
dustvoice@DustArch ~
$ gpg --card-status
dustvoice@DustArch ~
$ gpg --card-edit
----

[source, console]
----
(insert) gpg/card> fetch
(insert) gpg/card> q
----

[source, console]
----
dustvoice@DustArch ~
$ gpg-connect-agent updatestartuptty /bye
----

[NOTE]
====
You would have to adapt the `keygrip` present in the `~/.gnupg/sshcontrol` file to your specific `keygrip`, retrieved with `gpg -K --with-keygrip`.
====

Now, as mentioned before, I'll switch to using `ssh` for authentication, rather than `https`

[source, console]
----
dustvoice@DustArch ~
$ git remote set-url origin git@github.com:DustVoice/dotfiles.git
----

As the best method to both make `zsh` recognize all the configuration changes, as well as the `gpg-agent` behave properly, is to re-login, we'll do just that

[source, console]
----
dustvoice@DustArch ~
$ exit
----

[WARNING]
====
It is very important to note, that I mean *a real re-login*.

That means that if you've used `ssh` to log into your machine, it probably won't be sufficient to login into a new `ssh` session.
You'll probably need to restart the machine completely.
====

<<<

==== Finalize the `dotfiles`

Now log back in and continue

[source, console]
----
dustvoice@DustArch ~
$ git submodule update --init --recursive
dustvoice@DustArch ~
$ source .zshrc
dustvoice@DustArch ~
$ cd .config/nvim
dustvoice@DustArch ~/.config/nvim
$ echo 'let g:platform = "linux"' >> platform.vim
dustvoice@DustArch ~/.config/nvim
$ echo 'let g:use_autocomplete = 3' >> custom.vim
dustvoice@DustArch ~/.config/nvim
$ echo 'let g:use_clang_format = 1' >> custom.vim
dustvoice@DustArch ~/.config/nvim
$ echo 'let g:use_font = 0' >> custom.vim
dustvoice@DustArch ~/.config/nvim
$ sudo pip3 install neovim
dustvoice@DustArch ~/.config/nvim
$ nvim --headless +PlugInstall +qa
dustvoice@DustArch ~/.config/nvim
$ cd plugged/YouCompleteMe
dustvoice@DustArch ~/.config/nvim/plugged/YouCompleteMe
$ python3 install.py --clang-completer --java-completer
dustvoice@DustArch ~/.config/nvim/plugged/YouCompleteMe
$ cd ~
----

<<<

==== `gpg-agent` forwarding

Now there is only one thing left to do, in order to make the `gpg` setup complete: `gpg-agent` forwarding over `ssh`.
This is very important for me, as I want to use my smartcard on my development server too, which requires me, to forward/tunnel my `gpg-agent` to my remote machine.

First of all, I want to setup a config file for `ssh`, as I don't want to pass all parameters manually to ssh every time.

.~/.ssh/config

[source, text]
----
Host <connection name>
    HostName <remote address>
    ForwardAgent yes
    ForwardX11 yes
    RemoteForward <remote agent-socket> <local agent-extra-socket>
    RemoteForward <remote agent-ssh-socket> <local agent-ssh-socket>
----

[NOTE]
====
You would of course, need to adapt the content in between the `<` and `>` brackets.

To get the paths needed as parameters for `RemoteForward`, issue

[source, console]
----
dustvoice@DustArch ~
$ !gpgconf --list-dirs
----
====

Now you'll still need to enable some settings on the remote machine(s).

./etc/ssh/sshd_config
[source, text]
----
StreamLocalBindUnlink yes
AllowAgentForwarding yes
X11Forwarding yes
----

Now just restart your remote machine(s) and you're ready to go.

<<<

==== `JUCE` and `FRUT`

Your personal environment will be complete, after getting `JUCE` and `FRUT`

[source, console]
----
dustvoice@DustArch ~
$ git clone https://github.com/WeAreROLI/JUCE.git
dustvoice@DustArch ~
$ cd JUCE
dustvoice@DustArch ~/JUCE
$ git checkout develop
dustvoice@DustArch ~/JUCE
$ cd ..
dustvoice@DustArch ~
$ git clone https://github.com/McMartin/FRUT.git
----

<<<

==== Back to your ``root``s

As mentioned before, you would now switch to the `root` user, either by logging in as `root`, or by using

[source, console]
----
dustvoice@DustArch ~
$ sudo -iu root
----

Now go back to <<setup-home>> to repeat all commands for the `root` user.

[WARNING]
====
A native login would be better compared to `sudo -iu root`, as there could be some complications, like already running `gpg-agent` instances, etc., which you would need to manually resolve, when using `sudo -iu root`.
====

<<<

=== Password management

I'm using `pass` as my password manager.
As we already installed it in the <<additional-tools-setup-home>> step and updated the `submodule` that holds our `.password-store`, there is nothing left to do in this step

<<<

=== `python`

Python has become really important for a magnitude of use cases.
We need `python3` in particular as well as `pip` for it.

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S python python-pip
----

[NOTE]
====
For `asciidoctor`, which will be installed in just a second, we also need to install the `pygments` module

[source, console]
----
dustvoice@DustArch ~
$ sudo pip3 install pygments
----
====

<<<

=== `ruby` & `asciidoctor`

In order to use `asciidoctor`, we have to install `ruby` and `rubygems`.
After that we can install `asciidoctor` and all its required gems.

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S ruby rubygems
dustvoice@DustArch ~
$ gem install asciidoctor asciidoctor-pdf asciidoctor-epub3 asciidoctor-latex pygments.rb --pre
----

Now the only thing left, in my case at least, is adding `~/.gem/ruby/2.7.0/bin` to your path.

[NOTE]
====
Please note that if you run a ruby version different from `2.7.0`, or if you upgrade your ruby version, you have to use the `bin` path for that version.
====

For `zsh` you'll want to add a new entry inside the `.zshpath` file

.~/.zshpath

[source, text]
----
path=("$HOME/.gem/ruby/2.7.0/bin")
----

which then gets sourced by the provided `.zshenv` file.

[NOTE]
====
You might have to re-``source`` the `.zshenv` file to make the changes take effect immediately

[source, console]
----
dustvoice@DustArch ~
$ source .zshenv
----
====

[NOTE]
====
If you want to add a new entry to the `path` variable, you have to append it to the array

.~/.zshpath

[source, text]
----
path=("$HOME/.gem/ruby/2.7.0/bin" "$HOME/.gem/ruby/2.6.0/bin")
----
====

[NOTE]
====
If you use another shell than `zsh`, you might have to do something different, to add a directory to your `PATH`.
====

<<<

=== Using `JUCE`

In order to use `JUCE`, you'll need to have some dependency packages installed

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S clang gcc freeglut alsa-lib gnutls libcurl-gnutls freetype2 jack2 libx11 libxcomposite libxinerama libxrandr mesa webkit2gtk
----

If you want to use every feature of `JUCE` you'll need to install 2 more packages

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S ladspa lib32-freeglut
----

<<<

=== Additional development tools

Here are just some examples of development tools one could install in addition to what we already have.

<<<

==== Code formatting

We already have `clang-format` as a code formatter, but this only works for ``C``-family languages.
For `java` stuff, we can use `astyle`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S astyle
----

<<<

==== Documentation

To generate a documentation from source code, I mostly use `doxygen`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S doxygen
----

<<<

==== Build tools

In addition to `make`, I'll often times use `ninja` for my builds

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S ninja
----

<<<

[#setting-up-fstab]
=== `fstab`

In my case, I'm sharing an `exFat` partition between my `DustArch` and my Windows.
This was a result of some major inconvenience because of some weird `NTFS` permission stuff, which apparently Windows didn't like.
Since I've avoided directly writing to Windows partitions since then, I'll quickly demonstrate what `fstab` entries I have and why

./etc/fstab
[source, text, linenums]
----
UUID=e26de048-6147-42e5-a34b-59f1a50621bb       /               ext4            rw,relatime             0 1

UUID="C8E3-A0FD"                                /boot           vfat            defaults                0 1

UUID="DC88-5A4E"                                /mnt/projects   exfat           rw,relatime             0 0

UUID=7A16569B51903310                           /mnt/data       ntfs            ro,nosuid,nodev,noauto  0 0
----

The

. entry should be pretty straight forward.
It's my root partition of my `DustArch` install.

. entry is quite important too.
It's my `EFI System Partition`, which gets mounted at boot time, in order to prevent kernel orphaning, which means, that the kernel version installed on the system doesn't match the one on the `boot` partition.

. entry is my shared `exFat` partition, which we are allowed to write to.

. entry is important, because of the options.
These options prevent me from modifying files on that `NTFS` partition.

<<<

=== Audio

Well, why wouldn't you want audio...

<<<

==== `alsa`

[NOTE]
====
You're probably better off using `pulseaudio` and/or `jack`.
====

To quickly setup audio this way, install `alsa` and `alsa-utils`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S alsa alsa-utils
----

Now choose the sound card you want to use

[source, console]
----
dustvoice@DustArch ~
$ cat /proc/asound/cards
----

and then create `/etc/asound.conf`

./etc/asound.conf
[source, text]
----
defaults.pcm.card 2
defaults.ctl.card 2
----

[NOTE]
====
It should be apparent, that you would have to switch out `2` with the number corresponding to the sound card you want to use.
====

<<<

==== `pulseaudio`

Some applications require `pulseaudio`, or work better with it, for example `discord`, so it might make sense to use `pulseaudio`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S pulseaudio pulsemixer pavucontrol
----

For enabling real-time priority for `pulseaudio` on Arch Linux, please make sure your user is part of the `audio` group and edit the file `/etc/pulse/daemon.conf`, so that you uncomment the lines

./etc/pulse/daemon.conf
[source, text]
----
high-priority = yes
nice-level = -11

realtime-scheduling = yes
realtime-priority = 5
----

If your system can handle the load, you can also increase the remixing quality, by changing the `resample-method`

./etc/pulse/daemon.conf
[source, text]
----
resample-method = speex-float-10
----

Of course a restart of the `pulseaudio` daemon is necessary to reflect the changes you just made

[source, console]
----
dustvoice@DustArch ~
$ pulseaudio --kill
dustvoice@DustArch ~
$ pulseaudio --start
----

<<<

==== `jack`

If you either want to manually control audio routing, or if you use some kind of audio application like `ardour`, you'll probably want to use `jack`.

To install `jack` and a GUI to configure it, just do

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S jack2 cadence
----

If you also want to use `pulseaudio` applications, that don't have native support for `jack`, you'll need to install `pulseaudio-jack`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S pulseaudio-jack
----

<<<

==== Audio handling

To also play audio, we need to install some other packages too

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S sox libao libmad libid3tag wavpack libpulse opus file twolame
----

Now you can simply do

[source, console]
----
dustvoice@DustArch ~
$ play audio.wav
dustvoice@DustArch ~
$ play audio.mp3
----

etc. to play audio.

<<<

=== Bluetooth

To set up Bluetooth, we need to install the `bluez` and `bluez-utils` packages in order to have at least a command line utility `bluetoothctl` to configure connections

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S bluez bluez-utils
----

Now we need to check if the `btusb` kernel module was already loaded

[source, console]
----
dustvoice@DustArch ~
$ sudo lsmod | grep btusb
----

After that we can enable and start the `bluetooth.service` service

[source, console]
----
dustvoice@DustArch ~
$ sudo systemctl enable bluetooth.service
dustvoice@DustArch ~
$ sudo systemctl start bluetooth.service
----

[NOTE]
====
To use `bluetoothctl` and get access to the Bluetooth device of your PC, your user needs to be a member of the `lp` group.
====

Now simply enter `bluetoothctl`

[source, console]
----
dustvoice@DustArch ~
$ bluetoothctl
----

In most cases your Bluetooth interface will be preselected and defaulted, but in some cases, you might need to first select the Bluetooth controller

[source, console]
----
(insert) [DustVoice]# list
(insert) [DustVoice]# select <MAC_address>
----

After that, power on the controller

[source, console]
----
(insert) [DustVoice]# power on
----

Now enter device discovery mode

[source, console]
----
(insert) [DustVoice]# scan on
----

and list found devices

[source, console]
----
(insert) [DustVoice]# devices
----

[NOTE]
====
You can turn device discovery mode off again, after your desired device has been found

[source, console]
----
(insert) [DustVoice]# scan off
----
====

Now turn on the agent

[source, console]
----
(insert) [DustVoice]# agent on
----

and pair with your device

[source, console]
----
(insert) [DustVoice]# pair <MAC_address>
----

[NOTE]
====
If your device doesn't support PIN verification you might need to manually trust the device

[source, console]
----
(insert) [DustVoice]# trust <MAC_address>
----
====

Finally connect to your device

[source, console]
----
(insert) [DustVoice]# connect <MAC_address>
----

[NOTE]
====
If your device is an audio device, of some kind you might have to install `pulseaudio-bluetooth` and append 2 lines to `/etc/pulse/system.pa` as well.

So first install `pulseaudio-bluetooth`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S pulseaudio-bluetooth
----

append the following 2 lines

./etc/pulse/system.pa
[source, text]
----
load-module module-bluetooth-policy
load-module module-bluetooth-discover
----

and restart `pulseaudio`

[source, console]
----
dustvoice@DustArch ~
$ pulseaudo --kill
dustvoice@DustArch ~
$ pulseaudo --start
----

====

If you want a GUI to do all of this, just install `blueman` and launch `blueman-manager`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S blueman
----

<<<

=== `tmux`

As I assume that you're still inside the native linux terminal, I would reccommend to install `tmux` which enables you to have multiple terminal instances (called `windows` in `tmux`) open at the same time.
This makes working with the linux terminal much easier.

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S tmux
----

[NOTE]
====
To view a list of keybinds, you just need to press `CTRL+b` followed by `?`.
====

<<<

=== Graphical desktop environment

If you decide, that you want to use a graphical desktop environment, you have to install additional packages in order for that to work.

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S xorg xorg-xinit xorg-drivers i3 i3status rofi ttf-hack xfce4-terminal arandr
----

<<<

==== NVIDIA

If you also want to use NVIDIA functionality, for example for `davinci-resolve`, you'll most likely need to install their proprietary driver

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S nvidia nvidia-utils nvidia-settings opencl-nvidia
----

[NOTE]
====
You would have to reboot sooner or later after installing the NVIDIA drivers.

Also to get the best performance, at least for something like screen capturing in `obs`, go to *X Server Display Configuration* inside `nvidia-settings`, switch to *Advanced* and enable *Force Composition Pipeline*, as well as *Force Full Composition Pipeline*.
====

<<<

==== Launching the graphical environment

After that you can now do `startx` in order to launch the graphical environment.

If anything goes wrong in the process, remember that you can press *Ctrl+Alt+<Number>* to switch ``tty``s.

<<<

===== The NVIDIA way

If you're using an NVIDIA graphics card, you might want to use `nvidia-xrun` instead of `startx`.
This has the advantage, of the `nvidia` kernel modules, as well as the `nouveau` ones not loaded at boot time, thus saving power.
`nvidia-xrun` will then load the correct kernel modules and run the `.nvidia-xinitrc` script in your home directory (for more file locations look into the documentation for `nvidia-xrun`).

[IMPORTANT]
====
At the time of writing, `nvidia-xrun` needs `sudo` permissions before executing its task.
====

Simply install `nvidia-xrun`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S nvidia bbswitch
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/nvidia-xrun.git
dustvoice@DustArch ~/AUR
$ cd nvidia-xrun
dustvoice@DustArch ~/AUR/nvidia-xrun
$ makepkg -si
dustvoice@DustArch ~/AUR/nvidia-xrun
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/nvidia-xrun
$ git clean -fdx
----

[NOTE]
====
If your hardware doesn't support `bbswitch`, you would need to run

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S nvidia
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/nvidia-xrun-pm.git
dustvoice@DustArch ~/AUR
$ cd nvidia-xrun-pm
dustvoice@DustArch ~/AUR/nvidia-xrun-pm
$ makepkg -si
dustvoice@DustArch ~/AUR/nvidia-xrun-pm
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/nvidia-xrun-pm
$ git clean -fdx
----

instead.
====

Now we need to blacklist *both `nouveau` and `nvidia`* kernel modules.

To do that, we first have to find out, where our active `modprobe.d` directory is located.
There are 2 possible locations, generally speaking: `/etc/modprobe.d` and `/usr/lib/modprobe.d`.
In my case it was the latter, which I could tell, because this directory already had files in it.

Now I'll create a new file named `nvidia-xrun.conf` and write the following into it

./usr/lib/modprobe.d/nvidia-xrun.conf
[source, text, linenums]
----
blacklist nvidia
blacklist nvidia-drm
blacklist nvidia-modeset
blacklist nvidia-uvm
blacklist nouveau
----

With this config in place,

[source, console]
----
dustvoice@DustArch ~
$ lsmod | grep nvidia
----

and

[source, console]
----
dustvoice@DustArch ~
$ lsmod | grep nouveau
----

should return no output.
Else you might have to place some additional entries into the file.

[NOTE]
====
Of course, you'll need to reboot, after blacklisting the modules and before issuing the 2 commands mentioned.
====

[NOTE]
====
If you installed `nvidia-xrun-pm` instead of `nvidia-xrun` and `bbswitch`, you might want to also enable the `nvidia-xrun-pm` service

[source, console]
----
dustvoice@dustArch ~
$ sudo systemctl enable nvidia-xrun-pm.service
----
====

[NOTE]
====
The required `.nvidia-xinitrc` file, mentioned previously, should already be provided in the `dotfiles` repository.
====

Now instead of `startx`, just run `nvidia-xrun`, enter your `sudo` password and you're good to go.

<<<

=== GUI Software

As you now have a working graphical desktop environment, you might want to install some software to utilize your newly gained power.

<<<

==== Session Lock

Probably the first thing you'll want to set up is a session locker, which locks your ``X``-session after resuming from sleep, hibernation, etc.
It then requires you to input your password again, so no unauthorized user can access you machine.

I'll use `xss-lock` to hook into the necessary `systemd` events and `i3lock` as my locker.

For that I have to install both

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S xss-lock i3lock
----

And we're done actually, as I have placed the required command to start `xss-lock` with the right parameters inside my `i3` configuration file.

If you use something other than `i3`, you need to make sure this command gets executed upon start of the ``X``-session

[source, text]
----
xss-lock -- i3lock -n -e -c 333333
----

==== `xfce-polkit`

In order for GUI applications to acquire `sudo` permissions, we need to install a `PolicyKit` authentication agent.

We could use `gnome-polkit` for that purpose, which resides inside the official repositories, but I decided on using `xfce-polkit` from the `AUR`.

[source, console]
----
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/xfce-polkit.git
dustvoice@DustArch ~/AUR
$ cd xfce-polkit
dustvoice@DustArch ~/AUR/xfce-polkit
$ makepkg -si
dustvoice@DustArch ~/AUR/xfce-polkit
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/xfce-polkit
$ git clean -fdx
----

Now you just need to startup `xfce-polkit` before trying to execute something like `gparted` and you'll be prompted for your password.

As I already launch it as a part of my `i3` configuration, I won't have to worry about that.

==== Desktop background

You might want to consider installing `nitrogen`, in order to be able to set a background image

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S nitrogen
----

<<<

==== Compositing software

To get buttery smooth animation as well as e.g. smooth video playback in `brave` without screen tearing, you might want to consider using a compositor, in my case one named `picom`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S picom
----

Now edit the file `~/.config/i3/config` and uncomment the `picom` line in order to start `picom` with `i3`.

[WARNING]
====
In order for ``obs``' screen capture to work correctly, you need to kill `picom` completely before using `obs`.

[source, console]
----
dustvoice@DustArch ~
$ pkill picom
----

or

[source, console]
----
dustvoice@DustArch ~
$ ps aux | grep picom
dustvoice@DustArch ~
$ kill -9 <pid>
----
====

<<<

==== `networkmanager` applet

To install the `NetworkManager` applet, which lives in your tray and provides you with a quick method to connect to different networks, you have to install the `network-manager-applet` package

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S network-manager-applet
----

Now you can start the applet with

[source, console]
----
dustvoice@DustArch ~
$ nm-applet &
----

If you want to edit the network connections with a more full screen approach, you can also launch `nm-connection-editor`.

[NOTE]
====
The `nm-connection-editor` doesn't search for available Wi-Fis.
You would have to set up a Wi-Fi connection completely by hand, which could be desirable depending on how difficult to set up your Wi-Fi is.
====

<<<

==== Keyboard

To show, which keyboard layout and variant is currently in use, you can use `xkblayout-state`, which you can acquire from the `AUR`

[source, console]
----
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/xkblayout-state.git
dustvoice@DustArch ~/AUR
$ cd xkblayout-state
dustvoice@DustArch ~/AUR/xkblayout-state
$ makepkg -si
dustvoice@DustArch ~/AUR/xkblayout-state
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/xkblayout-state
$ git clean -fdx
----

Now simply issue the `layout` alias, provided by our custom `fish` configuration.

<<<

==== X clipboard

To copy something from the terminal to the `xorg` clipboard, use `xclip`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S xclip
dustvoice@DustArch ~
$ xclip some_random_text
----

<<<

==== Taking screen shots

For this functionality, especially in combination with `rofi`, use `scrot`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S scrot
----

`scrot ~/Pictures/filename.png` then saves the screen shot under `~/Pictures/filename.png`.

<<<

==== Image viewer

Now that we can create screen shots, we might also want to view those

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S ristretto
dustvoice@DustArch ~
$ ristretto filename.png
----

<<<

==== File manager

You probably also want to use a file manager.
In my case, `thunar`, the `xfce` file manager, worked best.

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S thunar
----

To also be able to `mount` removable drives, without being `root` or using `sudo`, and in order to have a GUI for mounting stuff, you would need to install `gigolo` and `gvfs`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S gvfs
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/gigolo.git
dustvoice@DustArch ~/AUR
$ cd gigolo
dustvoice@DustArch ~/AUR/gigolo
$ makepkg -si
dustvoice@DustArch ~/AUR/gigolo
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/gigolo
$ git clean -fdx
----

<<<

===== Android file transfer

To furthermore enable the transfer of files between your PC and your android phone, you'll have to install `mtp` and `gvfs-mtp`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S libmtp gvfs-mtp
----

Now you should be able to see your phone inside either `thunar`, or `gigolo`.

If you want to access the android's file system from the command line, you will need to either install and use `simple-mtpfs`, or `adb`

====== `simple-mtpfs`

Install `simple-mtpfs`

[source, console]
----
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/simple-mtpfs.git
dustvoice@DustArch ~/AUR
$ cd simple-mtpfs
dustvoice@DustArch ~/AUR/simple-mtpfs
$ makepkg -si
dustvoice@DustArch ~/AUR/simple-mtpfs
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/simple-mtpfs
$ git clean -fdx
----

edit `/etc/fuse.conf` to uncomment

./etc/fuse.conf
[source, text]
----
user_allow_other
----

and mount the android device

[source, console]
----
dustvoice@DustArch ~
$ simple-mtpfs -l
dustvoice@DustArch ~
$ mkdir ~/mnt
dustvoice@DustArch ~
$ simple-mtpfs --device <number> ~/mnt -allow_other
----

and respectively unmount it

[source, console]
----
dustvoice@DustArch ~
$ fusermount -u mnt
dustvoice@DustArch ~
$ rmdir mnt
----

====== `adb`

Install `adb`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S adb
----

kill the `adb` server, if it is running

[source, console]
----
dustvoice@DustArch ~
$ adb kill-server
----

[NOTE]
====
If the server is currently not running, `adb` will output an error with a `Connection refused` message.
====

Now connect your phone, unlock it and start the `adb` server

[source, console]
----
dustvoice@DustArch ~
$ adb start-server
----

If the PC is unknown to the android device, it will display a confirmation dialog.
Accept it and ensure that the device was recognized

[source, console]
----
dustvoice@DustArch ~
$ adb devices
----

Now you can ``push``/``pull`` files.

[source, console]
----
dustvoice@DustArch ~
$ adb pull /storage/emulated/0/DCIM/Camera/IMG.jpg .
dustvoice@DustArch ~
$ adb push IMG.jpg /storage/emulated/0/DCIM/Camera/IMG2.jpg
dustvoice@DustArch ~
$ adb kill-server
----

[NOTE]
====
Of course you would need to have the _developer options_ unlocked, as well as the _USB debugging_ option enabled within them, for `adb` to even work.
====

<<<

==== Archive manager

As we now have a file manager, it might be annoying, to open up a terminal every time you simply want to extract an archive of some sort.
That's why we'll install `xarchiver`.

In order for `xarchiver` to work at its full potential, we're first gonna install some additional archive types

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S p7zip zip unrar cpio
----

Now we can proceed to install `xarchiver`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S xarchiver
----

<<<

==== Partition management

You may also choose to use a graphical partitioning software instead of `fdisk` or `cfdisk`.
For that you can install `gparted`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S gparted
----

<<<

==== PDF viewer

As we've installed `asciidoctor-pdf` previously, you might be wondering how you are supposed to open the generated PDFs.
There are two ways.

<<<

===== Using the GUI

Installing `mupdf` is as simple as issuing

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S mupdf
----

If you want to have changes made to the PDF reflected immediately in the viewer, you would need `evince` instead

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S evince
----

<<<

===== Using the framebuffer

If you want to not always use the graphical desktop with `mupdf`, you might be interested in the `fbgs` software.

This software renders a PDF document using the native framebuffer.
To install it simply do

[source, console]
----
dustvoice@DustArch ~
$ pacman -S fbida ghostscript
----

and to view this PDF document (`Documentation.pdf`) for example, you would run

[source, console]
----
dustvoice@DustArch ~
$ fbgs Documentation.pdf
----

[INFO]
====
You can view all the controls by pressing `h`.
====

<<<

==== Web browser

As you're already using a GUI, you also might be interested in a web browser.
In my case, I'll install `brave` from the `AUR`, as well as `browserpass` from the official repositories, in order to use my passwords in `brave`.

[source, console]
----
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/brave-bin.git
dustvoice@DustArch ~/AUR
$ cd brave-bin
dustvoice@DustArch ~/AUR/brave-bin
$ makepkg -si
dustvoice@DustArch ~/AUR/brave-bin
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/brave-bin
$ git clean -fdx
dustvoice@DustArch ~
$ sudo pacman -S browserpass
----

Now we still have to setup `browserpass`

[source, console]
----
dustvoice@DustArch ~
$ cd /usr/lib/browserpass
dustvoice@DustArch /usr/lib/browserpass
$ make hosts-brave-user
dustvoice@DustArch /usr/lib/browserpass
$ make policies-brave-user
dustvoice@DustArch /usr/lib/browserpass
$ cd ~
----

Now the only thing left is, to fire up `brave` and install the `browserpass` extension from the chrome store.

<<<

===== Entering the dark side

You might want to be completely anonymous whilst browsing the web at some point.
Although this shouldn't be your only precaution, using `tor-browser` would be the first thing to do

[source, console]
----
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/tor-browser.git
dustvoice@DustArch ~/AUR
$ cd tor-browser
dustvoice@DustArch ~/AUR/tor-browser
$ makepkg -si
dustvoice@DustArch ~/AUR/tor-browser
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/tor-browser
$ git clean -fdx
----

[NOTE]
====
You might have to check out how to import the `gpg` keys on the `AUR` page of `tor-browser`.
====

<<<

==== Office utilities

For now we'll install `libreoffice-fresh`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S libreoffice-fresh
----

<<<

===== Printing

In order for printing to work with my printer, I had to install `avahi`, `cups`, `cups-pdf`, `nss-mdns` and the correspoding driver for my printer.
In order to be able to print from the `gtk` print dialog, we'll also need to install `system-config-printer` and `print-manager`.

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S avahi
dustvoice@DustArch ~
$ sudo pacman -S cups cups-pdf nss-mdns
dustvoice@DustArch ~
$ sudo systemctl enable avahi-daemon.service
dustvoice@DustArch ~
$ sudo systemctl start avahi-daemon.service
----

Now you have to edit `/etc/nsswitch.conf`

so this line

./etc/nsswitch.conf
[source, text]
----
hosts: files mymachines myhostname resolve [!UNAVAIL=return] dns
----

becomes this line

./etc/nsswitch.conf
[source, text]
----
hosts: files mymachines myhostname mdns4_minimal [NOTFOUND=return] resolve [!UNAVAIL=return] dns
----

Now continue with this

[source, console]
----
dustvoice@DustArch ~
$ avahi-browse --all --ignore-local --resolve --terminate
dustvoice@DustArch ~
$ sudo systemctl enable org.cups.cupsd.service
dustvoice@DustArch ~
$ sudo systemctl start org.cups.cupsd.service
dustvoice@DustArch ~
$ sudo pacman -S system-config-printer print-manager
----

Just open up `system-config-printer` now and configure your printer.

To test if everything is working, you could open up `brave`, then go to *Print* and then try printing.

<<<

==== Process management

The native tool is `top`.

The next evolutionary step would be `htop`, which is an improved version of `top` (like `vi` and `vim` for example)

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S htop
----

If you prefer a GUI for that kind of task, install `xfce4-taskmanager`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S xfce4-taskmanager
----

<<<

==== Communication

Life is all about communicating.
Here are some pieces of software to do exactly that.

<<<

===== Email

There is nothing better than some classical email.

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S thunderbird
----

<<<

===== Telegram

You want to have your `telegram` messages on your desktop PC?

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S telegram-desktop
----

<<<

===== TeamSpeak 3

Wanna chat with your gaming friends and they have a `teamspeak3` server?
Go for it

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S teamspeak3
----

<<<

===== Discord

You'd rather use `discord`?
No problem

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S discord
----

<<<

==== Video software

Just some additional software related to videos.

<<<

===== Viewing video

You might consider using `vlc`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S vlc
----

<<<

===== Creating video

`obs` should be the right choice

[source, console]
----
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/obs-studio-git
dustvoice@DustArch ~/AUR
$ cd obs-studio-git
dustvoice@DustArch ~/AUR/obs-studio-git
$ makepkg -si
dustvoice@DustArch ~/AUR/obs-studio-git
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/obs-studio-git
$ git clean -fdx
----

====== Showing keystrokes

In order to show the viewers what keystrokes you're pressing, you can use something like `screenkey`

[source, console]
----
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/screenkey.git
dustvoice@DustArch ~/AUR
$ cd screenkey
dustvoice@DustArch ~/AUR/screenkey
$ makepkg -si
dustvoice@DustArch ~/AUR/screenkey
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/screenkey
$ git clean -fdx
dustvoice@DustArch ~
$ screenkey
----

[NOTE]
====
For ideal use with `obs`, my `dotfiles` repository already provides you with the `screenkey-obs` script for you to run with `fish`.
====

<<<

===== Live stream a terminal session

For this task, you'll need a program called `tmate`.
Just install

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S tmate
----

and run it

[source, console]
----
dustvoice@DustArch ~
$ tmate
----

<<<

===== Editing video

In my case, I'm using `davinci-resolve`.

[source, console]
----
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/davinci-resolve.git
dustvoice@DustArch ~/AUR
$ cd davinci-resolve
dustvoice@DustArch ~/AUR/davinci-resolve
$ makepkg -si
dustvoice@DustArch ~/AUR/davinci-resolve
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/davinci-resolve
$ git clean -fdx
----

<<<

===== Utilizing video

Wanna remote control your own or another PC?
`teamviewer` might just be the right choice for you

[source, console]
----
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/teamviewer.git
dustvoice@DustArch ~/AUR
$ cd teamviewer
dustvoice@DustArch ~/AUR/teamviewer
$ makepkg -si
dustvoice@DustArch ~/AUR/teamviewer
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/teamviewer
$ git clean -fdx
----

<<<

==== Ardour

To e.g. edit and produce audio, I would recommend `ardour`, because it's easy to use, stable and cross platform.

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S ardour
----

[NOTE]
====
You might have to edit `/etc/security/limits.conf`, to increase the allowed locked memory amount.

In my case I have 32GB of RAM and I want the `audio` group to be allocate most of the RAM, which is why I added the following line to the file

./etc/security/limits.conf
[source, text]
----
@audio - memlock 29360128
----
====

[INFO]
====
Ardour won't natively save in the `mp3` format, due to licensing stuff.
In order to create `mp3` files, for sharing with other devices, because they have problems with `wav` files, for example, you can just use `ffmpeg`.

First make sure it's installed

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S ffmpeg
----

and after that we're going to convert `in.wav` to `out.mp3`

[source, console]
----
dustvoice@DustArch ~
$ ffmpeg -i in.wav -acodec mp3 out.mp3
----
====

<<<

==== Virtualization

You might need to run another OS, for example Mac OS, from within Linux, e.g. for development/testing purposes.
For that you can use `virtualbox`

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S virtualbox virtualbox-host-modules-arch
----

Now when you want to use `virtualbox` just load the kernel module

[source, console]
----
dustvoice@DustArch ~
$ sudo modprobe vboxdrv
----

and add the user which is supposed to run `virtualbox` to the `vboxusers` group

[source, console]
----
dustvoice@DustArch ~
$ sudo usermod -a G vboxusers $USER
----

and if you want to use `rawdisk` functionality, also to the `disk` group

[source, console]
----
dustvoice@DustArch ~
$ sudo usermod -a G disk $USER
----

Now just re-login and you're good to go.

// Longterm TODO: After getting a system with 2 GPUs, add part for KVMing a Windows.
// Resources:
// - virt-manager
// - wiki.archlinux.org/index.php/KVM
// - wiki.debian.org/VGAPassthrough
// - ycnrg.org/vga-passthrough-with-ovmf-vfio
// - bufferoverflow.io/gpu-passthrough
// - heiko-sieger.info/running-windows-10-on-linux-using-kvm-with-vga-passthrough
// - openwebit.com/c/how-to-run-windows-vm-on-more-than-2-cores-under-kvm

<<<

==== Gaming

The first option for native/emulated gaming on Linux is obviously `steam`.

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S steam lib32-nvidia-utils pulseaudio pulseaudio-alsa lib32-libpulse
----

The second option would be `lutris`, a program, that configures a wine instance correctly, etc.

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S lutris
----

<<<

==== Wacom

In order to use a Wacom graphics tablet, you'll have to install some packages

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -S libwacom xf86-input-wacom
----

You could now configure your tablet using the `xsetwacom` command.
But on the other hand there is also `wacom-utility`, a GUI software for all of that, so you could try if that works first.

[source, console]
----
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/wacom-utility.git
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/gksu.git
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/libgks.git
dustvoice@DustArch ~/AUR
$ cd libgks
dustvoice@DustArch ~/AUR/libgks
$ makepkg -si
dustvoice@DustArch ~/AUR/libgks
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/libgks
$ git clean -fdx
dustvoice@DustArch ~/AUR/libgks
$ cd ..
dustvoice@DustArch ~/AUR
$ cd gksu
dustvoice@DustArch ~/AUR/gksu
$ makepkg -si
dustvoice@DustArch ~/AUR/gksu
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/gksu
$ git clean -fdx
dustvoice@DustArch ~/AUR/gksu
$ cd ..
dustvoice@DustArch ~/AUR
$ cd wacom-utility
dustvoice@DustArch ~/AUR/wacom-utility
$ makepkg -si
dustvoice@DustArch ~/AUR/wacom-utility
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/wacom-utility
$ git clean -fdx
----

<<<

==== `VNC` & `RDP`

In order to connect to a machine over `VNC` or to connect to a machine using the `Remote Desktop Protocol`, for example to connect to a Windows machine, I'll need to install `freerdp` from the `AUR`, as well as `libvncserver`, for `RDP` and `VNC` functionality respectively, as well as `remmina`, to have a GUI client for those two protocols.

[source, console]
----
dustvoice@DustArch ~
$ cd AUR
dustvoice@DustArch ~/AUR
$ git clone https://aur.archlinux.org/freerdp.git
dustvoice@DustArch ~/AUR
$ cd freerdp
dustvoice@DustArch ~/AUR/freerdp
$ makepkg -si
dustvoice@DustArch ~/AUR/freerdp
$ git reset HEAD --hard
dustvoice@DustArch ~/AUR/freerdp
$ git clean -fdx
dustvoice@DustArch ~/AUR/freerdp
$ cd ~
dustvoice@DustArch ~
$ sudo pacman -S libvncserver remmina
----

Now you can set up all your connections inside `remmina`.

== Upgrading the system

You're probably wondering why this gets a dedicated section.

You'll probably think that it would be just a matter of issuing

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -Syu
----

That's both true and false.

You have to make sure, *that your boot partition is mounted at `/boot`* in order for everything to upgrade correctly.
That's because the moment you upgrade the `linux` package without having the correct partition mounted at `/boot`, your system won't boot.
You also might have to do `grub-mkconfig -o /boot/grub/grub.cfg` after you install a different kernel image.

If your system *indeed doesn't boot* and *boots to a recovery console*, then double check that the issue really is the not perfectly executed kernel update by issuing

[source, console]
----
root@DustArch ~
$ uname -a
----

and

[source, console]
----
root@DustArch ~
$ pacman -Q linux
----

*The version of these two packages should be exactly the same!*

If it isn't there is an easy fix for it.

<<<

=== Fixing a faulty kernel upgrade

First off we need to restore the old `linux` package.

For that note the version number of

[source, console]
----
root@DustArch ~
$ uname -a
----

Now we'll make sure first that nothing is mounted at `/boot`, because the process will likely create some unwanted files.
The process will also create a new `/boot` folder, which we're going to delete afterwards.

[source, console]
----
root@DustArch ~
$ umount /boot
----

Now `cd` into ``pacman``'s package cache

[source, console]
----
root@DustArch ~
$ cd /var/cache/pacman/pkg
----

There should be a file located named something like `linux-<version>.pkg.tar.xz`, where `<version>` would be somewhat equivalent to the previously noted version number

Now downgrade the `linux` package

[source, console]
----
root@DustArch ~
$ pacman -U linux-<version>.pkg.tar.xz
----

After that remove the possibly created `/boot` directory

[source, console]
----
root@DustArch ~
$ rm -rf /boot
root@DustArch ~
$ mkdir /boot
----

Now reboot and `mount` the `boot` partition, in my case an `EFI System Partition`.

Now simply rerun

[source, console]
----
dustvoice@DustArch ~
$ sudo pacman -Syu
----

and you should be fine now.

[NOTE]
====
Consider setting up an `fstab` entry for the `boot` partition, in order to avoid such dilemma in the future.

See <<setting-up-fstab>> for more.
====
